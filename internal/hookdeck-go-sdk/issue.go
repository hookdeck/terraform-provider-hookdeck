// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/hookdeck/hookdeck-go-sdk/internal"
	time "time"
)

type IssueCountRequest struct {
	Id             []*string                 `json:"-" url:"id,omitempty"`
	IssueTriggerId []*string                 `json:"-" url:"issue_trigger_id,omitempty"`
	Type           *IssueCountRequestType    `json:"-" url:"type,omitempty"`
	Status         *IssueCountRequestStatus  `json:"-" url:"status,omitempty"`
	MergedWith     []*string                 `json:"-" url:"merged_with,omitempty"`
	CreatedAt      *time.Time                `json:"-" url:"created_at,omitempty"`
	FirstSeenAt    *time.Time                `json:"-" url:"first_seen_at,omitempty"`
	LastSeenAt     *time.Time                `json:"-" url:"last_seen_at,omitempty"`
	DismissedAt    *time.Time                `json:"-" url:"dismissed_at,omitempty"`
	OrderBy        *IssueCountRequestOrderBy `json:"-" url:"order_by,omitempty"`
	Dir            *IssueCountRequestDir     `json:"-" url:"dir,omitempty"`
	Limit          *int                      `json:"-" url:"limit,omitempty"`
	Next           *string                   `json:"-" url:"next,omitempty"`
	Prev           *string                   `json:"-" url:"prev,omitempty"`
}

type IssueListRequest struct {
	Id             []*string                `json:"-" url:"id,omitempty"`
	IssueTriggerId []*string                `json:"-" url:"issue_trigger_id,omitempty"`
	Type           *IssueListRequestType    `json:"-" url:"type,omitempty"`
	Status         *IssueListRequestStatus  `json:"-" url:"status,omitempty"`
	MergedWith     []*string                `json:"-" url:"merged_with,omitempty"`
	CreatedAt      *time.Time               `json:"-" url:"created_at,omitempty"`
	FirstSeenAt    *time.Time               `json:"-" url:"first_seen_at,omitempty"`
	LastSeenAt     *time.Time               `json:"-" url:"last_seen_at,omitempty"`
	DismissedAt    *time.Time               `json:"-" url:"dismissed_at,omitempty"`
	OrderBy        *IssueListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	Dir            *IssueListRequestDir     `json:"-" url:"dir,omitempty"`
	Limit          *int                     `json:"-" url:"limit,omitempty"`
	Next           *string                  `json:"-" url:"next,omitempty"`
	Prev           *string                  `json:"-" url:"prev,omitempty"`
}

// Delivery issue
type DeliveryIssue struct {
	// Issue ID
	Id string `json:"id" url:"id"`
	// ID of the project
	TeamId string      `json:"team_id" url:"team_id"`
	Status IssueStatus `json:"status" url:"status"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at" url:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at" url:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at" url:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty" url:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty" url:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty" url:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty" url:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at" url:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at" url:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty" url:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty" url:"reference,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliveryIssue) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeliveryIssue) GetTeamId() string {
	if d == nil {
		return ""
	}
	return d.TeamId
}

func (d *DeliveryIssue) GetStatus() IssueStatus {
	if d == nil {
		return ""
	}
	return d.Status
}

func (d *DeliveryIssue) GetOpenedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.OpenedAt
}

func (d *DeliveryIssue) GetFirstSeenAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.FirstSeenAt
}

func (d *DeliveryIssue) GetLastSeenAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.LastSeenAt
}

func (d *DeliveryIssue) GetLastUpdatedBy() *string {
	if d == nil {
		return nil
	}
	return d.LastUpdatedBy
}

func (d *DeliveryIssue) GetDismissedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.DismissedAt
}

func (d *DeliveryIssue) GetAutoResolvedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.AutoResolvedAt
}

func (d *DeliveryIssue) GetMergedWith() *string {
	if d == nil {
		return nil
	}
	return d.MergedWith
}

func (d *DeliveryIssue) GetUpdatedAt() string {
	if d == nil {
		return ""
	}
	return d.UpdatedAt
}

func (d *DeliveryIssue) GetCreatedAt() string {
	if d == nil {
		return ""
	}
	return d.CreatedAt
}

func (d *DeliveryIssue) GetAggregationKeys() *DeliveryIssueAggregationKeys {
	if d == nil {
		return nil
	}
	return d.AggregationKeys
}

func (d *DeliveryIssue) GetReference() *DeliveryIssueReference {
	if d == nil {
		return nil
	}
	return d.Reference
}

func (d *DeliveryIssue) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliveryIssue) UnmarshalJSON(data []byte) error {
	type embed DeliveryIssue
	var unmarshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeliveryIssue(unmarshaler.embed)
	d.OpenedAt = unmarshaler.OpenedAt.Time()
	d.FirstSeenAt = unmarshaler.FirstSeenAt.Time()
	d.LastSeenAt = unmarshaler.LastSeenAt.Time()
	d.DismissedAt = unmarshaler.DismissedAt.TimePtr()
	d.AutoResolvedAt = unmarshaler.AutoResolvedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliveryIssue) MarshalJSON() ([]byte, error) {
	type embed DeliveryIssue
	var marshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed:          embed(*d),
		OpenedAt:       internal.NewDateTime(d.OpenedAt),
		FirstSeenAt:    internal.NewDateTime(d.FirstSeenAt),
		LastSeenAt:     internal.NewDateTime(d.LastSeenAt),
		DismissedAt:    internal.NewOptionalDateTime(d.DismissedAt),
		AutoResolvedAt: internal.NewOptionalDateTime(d.AutoResolvedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DeliveryIssue) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Keys used as the aggregation keys a 'delivery' type issue
type DeliveryIssueAggregationKeys struct {
	WebhookId      []string            `json:"webhook_id,omitempty" url:"webhook_id,omitempty"`
	ResponseStatus []float64           `json:"response_status,omitempty" url:"response_status,omitempty"`
	ErrorCode      []AttemptErrorCodes `json:"error_code,omitempty" url:"error_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliveryIssueAggregationKeys) GetWebhookId() []string {
	if d == nil {
		return nil
	}
	return d.WebhookId
}

func (d *DeliveryIssueAggregationKeys) GetResponseStatus() []float64 {
	if d == nil {
		return nil
	}
	return d.ResponseStatus
}

func (d *DeliveryIssueAggregationKeys) GetErrorCode() []AttemptErrorCodes {
	if d == nil {
		return nil
	}
	return d.ErrorCode
}

func (d *DeliveryIssueAggregationKeys) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliveryIssueAggregationKeys) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliveryIssueAggregationKeys
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliveryIssueAggregationKeys(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliveryIssueAggregationKeys) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Delivery issue data
type DeliveryIssueData struct {
	TriggerEvent   *Event        `json:"trigger_event,omitempty" url:"trigger_event,omitempty"`
	TriggerAttempt *EventAttempt `json:"trigger_attempt,omitempty" url:"trigger_attempt,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliveryIssueData) GetTriggerEvent() *Event {
	if d == nil {
		return nil
	}
	return d.TriggerEvent
}

func (d *DeliveryIssueData) GetTriggerAttempt() *EventAttempt {
	if d == nil {
		return nil
	}
	return d.TriggerAttempt
}

func (d *DeliveryIssueData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliveryIssueData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliveryIssueData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliveryIssueData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliveryIssueData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Reference to the event and attempt an issue is being created for.
type DeliveryIssueReference struct {
	EventId   string `json:"event_id" url:"event_id"`
	AttemptId string `json:"attempt_id" url:"attempt_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliveryIssueReference) GetEventId() string {
	if d == nil {
		return ""
	}
	return d.EventId
}

func (d *DeliveryIssueReference) GetAttemptId() string {
	if d == nil {
		return ""
	}
	return d.AttemptId
}

func (d *DeliveryIssueReference) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliveryIssueReference) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliveryIssueReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliveryIssueReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliveryIssueReference) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Delivery issue
type DeliveryIssueWithData struct {
	// Issue ID
	Id string `json:"id" url:"id"`
	// ID of the project
	TeamId string      `json:"team_id" url:"team_id"`
	Status IssueStatus `json:"status" url:"status"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at" url:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at" url:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at" url:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty" url:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty" url:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty" url:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty" url:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at" url:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at" url:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty" url:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty" url:"reference,omitempty"`
	Data            *DeliveryIssueData            `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliveryIssueWithData) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeliveryIssueWithData) GetTeamId() string {
	if d == nil {
		return ""
	}
	return d.TeamId
}

func (d *DeliveryIssueWithData) GetStatus() IssueStatus {
	if d == nil {
		return ""
	}
	return d.Status
}

func (d *DeliveryIssueWithData) GetOpenedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.OpenedAt
}

func (d *DeliveryIssueWithData) GetFirstSeenAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.FirstSeenAt
}

func (d *DeliveryIssueWithData) GetLastSeenAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.LastSeenAt
}

func (d *DeliveryIssueWithData) GetLastUpdatedBy() *string {
	if d == nil {
		return nil
	}
	return d.LastUpdatedBy
}

func (d *DeliveryIssueWithData) GetDismissedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.DismissedAt
}

func (d *DeliveryIssueWithData) GetAutoResolvedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.AutoResolvedAt
}

func (d *DeliveryIssueWithData) GetMergedWith() *string {
	if d == nil {
		return nil
	}
	return d.MergedWith
}

func (d *DeliveryIssueWithData) GetUpdatedAt() string {
	if d == nil {
		return ""
	}
	return d.UpdatedAt
}

func (d *DeliveryIssueWithData) GetCreatedAt() string {
	if d == nil {
		return ""
	}
	return d.CreatedAt
}

func (d *DeliveryIssueWithData) GetAggregationKeys() *DeliveryIssueAggregationKeys {
	if d == nil {
		return nil
	}
	return d.AggregationKeys
}

func (d *DeliveryIssueWithData) GetReference() *DeliveryIssueReference {
	if d == nil {
		return nil
	}
	return d.Reference
}

func (d *DeliveryIssueWithData) GetData() *DeliveryIssueData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DeliveryIssueWithData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliveryIssueWithData) UnmarshalJSON(data []byte) error {
	type embed DeliveryIssueWithData
	var unmarshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeliveryIssueWithData(unmarshaler.embed)
	d.OpenedAt = unmarshaler.OpenedAt.Time()
	d.FirstSeenAt = unmarshaler.FirstSeenAt.Time()
	d.LastSeenAt = unmarshaler.LastSeenAt.Time()
	d.DismissedAt = unmarshaler.DismissedAt.TimePtr()
	d.AutoResolvedAt = unmarshaler.AutoResolvedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliveryIssueWithData) MarshalJSON() ([]byte, error) {
	type embed DeliveryIssueWithData
	var marshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed:          embed(*d),
		OpenedAt:       internal.NewDateTime(d.OpenedAt),
		FirstSeenAt:    internal.NewDateTime(d.FirstSeenAt),
		LastSeenAt:     internal.NewDateTime(d.LastSeenAt),
		DismissedAt:    internal.NewOptionalDateTime(d.DismissedAt),
		AutoResolvedAt: internal.NewOptionalDateTime(d.AutoResolvedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DeliveryIssueWithData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Issue
type Issue struct {
	Type           string
	Delivery       *DeliveryIssue
	Transformation *TransformationIssue
}

func NewIssueFromDelivery(value *DeliveryIssue) *Issue {
	return &Issue{Type: "delivery", Delivery: value}
}

func NewIssueFromTransformation(value *TransformationIssue) *Issue {
	return &Issue{Type: "transformation", Transformation: value}
}

func (i *Issue) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *Issue) GetDelivery() *DeliveryIssue {
	if i == nil {
		return nil
	}
	return i.Delivery
}

func (i *Issue) GetTransformation() *TransformationIssue {
	if i == nil {
		return nil
	}
	return i.Transformation
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i Issue) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return internal.MarshalJSONWithExtraProperty(i.Delivery, "type", "delivery")
	case "transformation":
		return internal.MarshalJSONWithExtraProperty(i.Transformation, "type", "transformation")
	}
}

type IssueVisitor interface {
	VisitDelivery(*DeliveryIssue) error
	VisitTransformation(*TransformationIssue) error
}

func (i *Issue) Accept(visitor IssueVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueCount struct {
	// Number of issues
	Count int `json:"count" url:"count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueCount) GetCount() int {
	if i == nil {
		return 0
	}
	return i.Count
}

func (i *IssueCount) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueCount) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueCount) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Issue status
type IssueStatus string

const (
	IssueStatusOpened       IssueStatus = "OPENED"
	IssueStatusIgnored      IssueStatus = "IGNORED"
	IssueStatusAcknowledged IssueStatus = "ACKNOWLEDGED"
	IssueStatusResolved     IssueStatus = "RESOLVED"
)

func NewIssueStatusFromString(s string) (IssueStatus, error) {
	switch s {
	case "OPENED":
		return IssueStatusOpened, nil
	case "IGNORED":
		return IssueStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueStatusAcknowledged, nil
	case "RESOLVED":
		return IssueStatusResolved, nil
	}
	var t IssueStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatus) Ptr() *IssueStatus {
	return &i
}

type IssueWithData struct {
	Type           string
	Delivery       *DeliveryIssueWithData
	Transformation *TransformationIssueWithData
}

func NewIssueWithDataFromDelivery(value *DeliveryIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "delivery", Delivery: value}
}

func NewIssueWithDataFromTransformation(value *TransformationIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "transformation", Transformation: value}
}

func (i *IssueWithData) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *IssueWithData) GetDelivery() *DeliveryIssueWithData {
	if i == nil {
		return nil
	}
	return i.Delivery
}

func (i *IssueWithData) GetTransformation() *TransformationIssueWithData {
	if i == nil {
		return nil
	}
	return i.Transformation
}

func (i *IssueWithData) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i IssueWithData) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return internal.MarshalJSONWithExtraProperty(i.Delivery, "type", "delivery")
	case "transformation":
		return internal.MarshalJSONWithExtraProperty(i.Transformation, "type", "transformation")
	}
}

type IssueWithDataVisitor interface {
	VisitDelivery(*DeliveryIssueWithData) error
	VisitTransformation(*TransformationIssueWithData) error
}

func (i *IssueWithData) Accept(visitor IssueWithDataVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueWithDataPaginatedResult struct {
	Pagination *SeekPagination  `json:"pagination,omitempty" url:"pagination,omitempty"`
	Count      *int             `json:"count,omitempty" url:"count,omitempty"`
	Models     []*IssueWithData `json:"models,omitempty" url:"models,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueWithDataPaginatedResult) GetPagination() *SeekPagination {
	if i == nil {
		return nil
	}
	return i.Pagination
}

func (i *IssueWithDataPaginatedResult) GetCount() *int {
	if i == nil {
		return nil
	}
	return i.Count
}

func (i *IssueWithDataPaginatedResult) GetModels() []*IssueWithData {
	if i == nil {
		return nil
	}
	return i.Models
}

func (i *IssueWithDataPaginatedResult) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueWithDataPaginatedResult) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueWithDataPaginatedResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueWithDataPaginatedResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueWithDataPaginatedResult) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Transformation issue
type TransformationIssue struct {
	// Issue ID
	Id string `json:"id" url:"id"`
	// ID of the project
	TeamId string      `json:"team_id" url:"team_id"`
	Status IssueStatus `json:"status" url:"status"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at" url:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at" url:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at" url:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty" url:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty" url:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty" url:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty" url:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at" url:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at" url:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty" url:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty" url:"reference,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransformationIssue) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TransformationIssue) GetTeamId() string {
	if t == nil {
		return ""
	}
	return t.TeamId
}

func (t *TransformationIssue) GetStatus() IssueStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransformationIssue) GetOpenedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.OpenedAt
}

func (t *TransformationIssue) GetFirstSeenAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.FirstSeenAt
}

func (t *TransformationIssue) GetLastSeenAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.LastSeenAt
}

func (t *TransformationIssue) GetLastUpdatedBy() *string {
	if t == nil {
		return nil
	}
	return t.LastUpdatedBy
}

func (t *TransformationIssue) GetDismissedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.DismissedAt
}

func (t *TransformationIssue) GetAutoResolvedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.AutoResolvedAt
}

func (t *TransformationIssue) GetMergedWith() *string {
	if t == nil {
		return nil
	}
	return t.MergedWith
}

func (t *TransformationIssue) GetUpdatedAt() string {
	if t == nil {
		return ""
	}
	return t.UpdatedAt
}

func (t *TransformationIssue) GetCreatedAt() string {
	if t == nil {
		return ""
	}
	return t.CreatedAt
}

func (t *TransformationIssue) GetAggregationKeys() *TransformationIssueAggregationKeys {
	if t == nil {
		return nil
	}
	return t.AggregationKeys
}

func (t *TransformationIssue) GetReference() *TransformationIssueReference {
	if t == nil {
		return nil
	}
	return t.Reference
}

func (t *TransformationIssue) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformationIssue) UnmarshalJSON(data []byte) error {
	type embed TransformationIssue
	var unmarshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransformationIssue(unmarshaler.embed)
	t.OpenedAt = unmarshaler.OpenedAt.Time()
	t.FirstSeenAt = unmarshaler.FirstSeenAt.Time()
	t.LastSeenAt = unmarshaler.LastSeenAt.Time()
	t.DismissedAt = unmarshaler.DismissedAt.TimePtr()
	t.AutoResolvedAt = unmarshaler.AutoResolvedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformationIssue) MarshalJSON() ([]byte, error) {
	type embed TransformationIssue
	var marshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed:          embed(*t),
		OpenedAt:       internal.NewDateTime(t.OpenedAt),
		FirstSeenAt:    internal.NewDateTime(t.FirstSeenAt),
		LastSeenAt:     internal.NewDateTime(t.LastSeenAt),
		DismissedAt:    internal.NewOptionalDateTime(t.DismissedAt),
		AutoResolvedAt: internal.NewOptionalDateTime(t.AutoResolvedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransformationIssue) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Keys used as the aggregation keys a 'transformation' type issue
type TransformationIssueAggregationKeys struct {
	TransformationId []string                        `json:"transformation_id,omitempty" url:"transformation_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel `json:"log_level" url:"log_level"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransformationIssueAggregationKeys) GetTransformationId() []string {
	if t == nil {
		return nil
	}
	return t.TransformationId
}

func (t *TransformationIssueAggregationKeys) GetLogLevel() TransformationExecutionLogLevel {
	if t == nil {
		return ""
	}
	return t.LogLevel
}

func (t *TransformationIssueAggregationKeys) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformationIssueAggregationKeys) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformationIssueAggregationKeys
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformationIssueAggregationKeys(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformationIssueAggregationKeys) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Transformation issue data
type TransformationIssueData struct {
	TransformationExecution *TransformationExecution `json:"transformation_execution,omitempty" url:"transformation_execution,omitempty"`
	TriggerAttempt          *EventAttempt            `json:"trigger_attempt,omitempty" url:"trigger_attempt,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransformationIssueData) GetTransformationExecution() *TransformationExecution {
	if t == nil {
		return nil
	}
	return t.TransformationExecution
}

func (t *TransformationIssueData) GetTriggerAttempt() *EventAttempt {
	if t == nil {
		return nil
	}
	return t.TriggerAttempt
}

func (t *TransformationIssueData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformationIssueData) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformationIssueData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformationIssueData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformationIssueData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Reference to the event request transformation an issue is being created for.
type TransformationIssueReference struct {
	TransformationExecutionId string `json:"transformation_execution_id" url:"transformation_execution_id"`
	// Deprecated but still found on historical issues
	TriggerEventRequestTransformationId *string `json:"trigger_event_request_transformation_id,omitempty" url:"trigger_event_request_transformation_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransformationIssueReference) GetTransformationExecutionId() string {
	if t == nil {
		return ""
	}
	return t.TransformationExecutionId
}

func (t *TransformationIssueReference) GetTriggerEventRequestTransformationId() *string {
	if t == nil {
		return nil
	}
	return t.TriggerEventRequestTransformationId
}

func (t *TransformationIssueReference) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformationIssueReference) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformationIssueReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformationIssueReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformationIssueReference) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Transformation issue
type TransformationIssueWithData struct {
	// Issue ID
	Id string `json:"id" url:"id"`
	// ID of the project
	TeamId string      `json:"team_id" url:"team_id"`
	Status IssueStatus `json:"status" url:"status"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at" url:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at" url:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at" url:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty" url:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty" url:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty" url:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty" url:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at" url:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at" url:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty" url:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty" url:"reference,omitempty"`
	Data            *TransformationIssueData            `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransformationIssueWithData) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TransformationIssueWithData) GetTeamId() string {
	if t == nil {
		return ""
	}
	return t.TeamId
}

func (t *TransformationIssueWithData) GetStatus() IssueStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransformationIssueWithData) GetOpenedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.OpenedAt
}

func (t *TransformationIssueWithData) GetFirstSeenAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.FirstSeenAt
}

func (t *TransformationIssueWithData) GetLastSeenAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.LastSeenAt
}

func (t *TransformationIssueWithData) GetLastUpdatedBy() *string {
	if t == nil {
		return nil
	}
	return t.LastUpdatedBy
}

func (t *TransformationIssueWithData) GetDismissedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.DismissedAt
}

func (t *TransformationIssueWithData) GetAutoResolvedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.AutoResolvedAt
}

func (t *TransformationIssueWithData) GetMergedWith() *string {
	if t == nil {
		return nil
	}
	return t.MergedWith
}

func (t *TransformationIssueWithData) GetUpdatedAt() string {
	if t == nil {
		return ""
	}
	return t.UpdatedAt
}

func (t *TransformationIssueWithData) GetCreatedAt() string {
	if t == nil {
		return ""
	}
	return t.CreatedAt
}

func (t *TransformationIssueWithData) GetAggregationKeys() *TransformationIssueAggregationKeys {
	if t == nil {
		return nil
	}
	return t.AggregationKeys
}

func (t *TransformationIssueWithData) GetReference() *TransformationIssueReference {
	if t == nil {
		return nil
	}
	return t.Reference
}

func (t *TransformationIssueWithData) GetData() *TransformationIssueData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TransformationIssueWithData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformationIssueWithData) UnmarshalJSON(data []byte) error {
	type embed TransformationIssueWithData
	var unmarshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransformationIssueWithData(unmarshaler.embed)
	t.OpenedAt = unmarshaler.OpenedAt.Time()
	t.FirstSeenAt = unmarshaler.FirstSeenAt.Time()
	t.LastSeenAt = unmarshaler.LastSeenAt.Time()
	t.DismissedAt = unmarshaler.DismissedAt.TimePtr()
	t.AutoResolvedAt = unmarshaler.AutoResolvedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformationIssueWithData) MarshalJSON() ([]byte, error) {
	type embed TransformationIssueWithData
	var marshaler = struct {
		embed
		OpenedAt       *internal.DateTime `json:"opened_at"`
		FirstSeenAt    *internal.DateTime `json:"first_seen_at"`
		LastSeenAt     *internal.DateTime `json:"last_seen_at"`
		DismissedAt    *internal.DateTime `json:"dismissed_at,omitempty"`
		AutoResolvedAt *internal.DateTime `json:"auto_resolved_at,omitempty"`
	}{
		embed:          embed(*t),
		OpenedAt:       internal.NewDateTime(t.OpenedAt),
		FirstSeenAt:    internal.NewDateTime(t.FirstSeenAt),
		LastSeenAt:     internal.NewDateTime(t.LastSeenAt),
		DismissedAt:    internal.NewOptionalDateTime(t.DismissedAt),
		AutoResolvedAt: internal.NewOptionalDateTime(t.AutoResolvedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransformationIssueWithData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type IssueCountRequestDir string

const (
	IssueCountRequestDirAsc  IssueCountRequestDir = "asc"
	IssueCountRequestDirDesc IssueCountRequestDir = "desc"
)

func NewIssueCountRequestDirFromString(s string) (IssueCountRequestDir, error) {
	switch s {
	case "asc":
		return IssueCountRequestDirAsc, nil
	case "desc":
		return IssueCountRequestDirDesc, nil
	}
	var t IssueCountRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestDir) Ptr() *IssueCountRequestDir {
	return &i
}

type IssueCountRequestOrderBy string

const (
	IssueCountRequestOrderByCreatedAt   IssueCountRequestOrderBy = "created_at"
	IssueCountRequestOrderByFirstSeenAt IssueCountRequestOrderBy = "first_seen_at"
	IssueCountRequestOrderByLastSeenAt  IssueCountRequestOrderBy = "last_seen_at"
	IssueCountRequestOrderByOpenedAt    IssueCountRequestOrderBy = "opened_at"
	IssueCountRequestOrderByStatus      IssueCountRequestOrderBy = "status"
)

func NewIssueCountRequestOrderByFromString(s string) (IssueCountRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueCountRequestOrderByCreatedAt, nil
	case "first_seen_at":
		return IssueCountRequestOrderByFirstSeenAt, nil
	case "last_seen_at":
		return IssueCountRequestOrderByLastSeenAt, nil
	case "opened_at":
		return IssueCountRequestOrderByOpenedAt, nil
	case "status":
		return IssueCountRequestOrderByStatus, nil
	}
	var t IssueCountRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestOrderBy) Ptr() *IssueCountRequestOrderBy {
	return &i
}

type IssueCountRequestStatus string

const (
	IssueCountRequestStatusOpened       IssueCountRequestStatus = "OPENED"
	IssueCountRequestStatusIgnored      IssueCountRequestStatus = "IGNORED"
	IssueCountRequestStatusAcknowledged IssueCountRequestStatus = "ACKNOWLEDGED"
	IssueCountRequestStatusResolved     IssueCountRequestStatus = "RESOLVED"
)

func NewIssueCountRequestStatusFromString(s string) (IssueCountRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueCountRequestStatusOpened, nil
	case "IGNORED":
		return IssueCountRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueCountRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueCountRequestStatusResolved, nil
	}
	var t IssueCountRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestStatus) Ptr() *IssueCountRequestStatus {
	return &i
}

type IssueCountRequestType string

const (
	IssueCountRequestTypeDelivery       IssueCountRequestType = "delivery"
	IssueCountRequestTypeTransformation IssueCountRequestType = "transformation"
	IssueCountRequestTypeBackpressure   IssueCountRequestType = "backpressure"
)

func NewIssueCountRequestTypeFromString(s string) (IssueCountRequestType, error) {
	switch s {
	case "delivery":
		return IssueCountRequestTypeDelivery, nil
	case "transformation":
		return IssueCountRequestTypeTransformation, nil
	case "backpressure":
		return IssueCountRequestTypeBackpressure, nil
	}
	var t IssueCountRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestType) Ptr() *IssueCountRequestType {
	return &i
}

type IssueListRequestDir string

const (
	IssueListRequestDirAsc  IssueListRequestDir = "asc"
	IssueListRequestDirDesc IssueListRequestDir = "desc"
)

func NewIssueListRequestDirFromString(s string) (IssueListRequestDir, error) {
	switch s {
	case "asc":
		return IssueListRequestDirAsc, nil
	case "desc":
		return IssueListRequestDirDesc, nil
	}
	var t IssueListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestDir) Ptr() *IssueListRequestDir {
	return &i
}

type IssueListRequestOrderBy string

const (
	IssueListRequestOrderByCreatedAt   IssueListRequestOrderBy = "created_at"
	IssueListRequestOrderByFirstSeenAt IssueListRequestOrderBy = "first_seen_at"
	IssueListRequestOrderByLastSeenAt  IssueListRequestOrderBy = "last_seen_at"
	IssueListRequestOrderByOpenedAt    IssueListRequestOrderBy = "opened_at"
	IssueListRequestOrderByStatus      IssueListRequestOrderBy = "status"
)

func NewIssueListRequestOrderByFromString(s string) (IssueListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueListRequestOrderByCreatedAt, nil
	case "first_seen_at":
		return IssueListRequestOrderByFirstSeenAt, nil
	case "last_seen_at":
		return IssueListRequestOrderByLastSeenAt, nil
	case "opened_at":
		return IssueListRequestOrderByOpenedAt, nil
	case "status":
		return IssueListRequestOrderByStatus, nil
	}
	var t IssueListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestOrderBy) Ptr() *IssueListRequestOrderBy {
	return &i
}

type IssueListRequestStatus string

const (
	IssueListRequestStatusOpened       IssueListRequestStatus = "OPENED"
	IssueListRequestStatusIgnored      IssueListRequestStatus = "IGNORED"
	IssueListRequestStatusAcknowledged IssueListRequestStatus = "ACKNOWLEDGED"
	IssueListRequestStatusResolved     IssueListRequestStatus = "RESOLVED"
)

func NewIssueListRequestStatusFromString(s string) (IssueListRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueListRequestStatusOpened, nil
	case "IGNORED":
		return IssueListRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueListRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueListRequestStatusResolved, nil
	}
	var t IssueListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestStatus) Ptr() *IssueListRequestStatus {
	return &i
}

type IssueListRequestType string

const (
	IssueListRequestTypeDelivery       IssueListRequestType = "delivery"
	IssueListRequestTypeTransformation IssueListRequestType = "transformation"
	IssueListRequestTypeBackpressure   IssueListRequestType = "backpressure"
)

func NewIssueListRequestTypeFromString(s string) (IssueListRequestType, error) {
	switch s {
	case "delivery":
		return IssueListRequestTypeDelivery, nil
	case "transformation":
		return IssueListRequestTypeTransformation, nil
	case "backpressure":
		return IssueListRequestTypeBackpressure, nil
	}
	var t IssueListRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestType) Ptr() *IssueListRequestType {
	return &i
}

// New status
type IssueUpdateRequestStatus string

const (
	IssueUpdateRequestStatusOpened       IssueUpdateRequestStatus = "OPENED"
	IssueUpdateRequestStatusIgnored      IssueUpdateRequestStatus = "IGNORED"
	IssueUpdateRequestStatusAcknowledged IssueUpdateRequestStatus = "ACKNOWLEDGED"
	IssueUpdateRequestStatusResolved     IssueUpdateRequestStatus = "RESOLVED"
)

func NewIssueUpdateRequestStatusFromString(s string) (IssueUpdateRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueUpdateRequestStatusOpened, nil
	case "IGNORED":
		return IssueUpdateRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueUpdateRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueUpdateRequestStatusResolved, nil
	}
	var t IssueUpdateRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueUpdateRequestStatus) Ptr() *IssueUpdateRequestStatus {
	return &i
}

type IssueUpdateRequest struct {
	// New status
	Status IssueUpdateRequestStatus `json:"status" url:"-"`
}
