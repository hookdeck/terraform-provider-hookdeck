// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	core "github.com/hookdeck/hookdeck-go-sdk/core"
	internal "github.com/hookdeck/hookdeck-go-sdk/internal"
)

type IssueTriggerCreateRequest struct {
	Type IssueType `json:"type" url:"-"`
	// Configuration object for the specific issue type selected
	Configs  *core.Optional[IssueTriggerCreateRequestConfigs] `json:"configs,omitempty" url:"-"`
	Channels *core.Optional[IssueTriggerChannels]             `json:"channels,omitempty" url:"-"`
	// Optional unique name to use as reference when using the API
	Name *core.Optional[string] `json:"name,omitempty" url:"-"`
}

type IssueTriggerListRequest struct {
	Name       *string                         `json:"-" url:"name,omitempty"`
	Type       *IssueType                      `json:"-" url:"type,omitempty"`
	DisabledAt *time.Time                      `json:"-" url:"disabled_at,omitempty"`
	OrderBy    *IssueTriggerListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	Dir        *IssueTriggerListRequestDir     `json:"-" url:"dir,omitempty"`
	Limit      *int                            `json:"-" url:"limit,omitempty"`
	Next       *string                         `json:"-" url:"next,omitempty"`
	Prev       *string                         `json:"-" url:"prev,omitempty"`
}

type DeletedIssueTriggerResponse struct {
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeletedIssueTriggerResponse) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeletedIssueTriggerResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletedIssueTriggerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletedIssueTriggerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletedIssueTriggerResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletedIssueTriggerResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type IssueTrigger struct {
	// ID of the issue trigger
	Id string `json:"id" url:"id"`
	// ID of the project
	TeamId *string `json:"team_id,omitempty" url:"team_id,omitempty"`
	// Optional unique name to use as reference when using the API
	Name     *string                `json:"name,omitempty" url:"name,omitempty"`
	Type     IssueType              `json:"type" url:"type"`
	Configs  *IssueTriggerReference `json:"configs,omitempty" url:"configs,omitempty"`
	Channels *IssueTriggerChannels  `json:"channels,omitempty" url:"channels,omitempty"`
	// ISO timestamp for when the issue trigger was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty" url:"disabled_at,omitempty"`
	// ISO timestamp for when the issue trigger was last updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// ISO timestamp for when the issue trigger was created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// ISO timestamp for when the issue trigger was deleted
	DeletedAt *time.Time `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTrigger) GetId() string {
	if i == nil {
		return ""
	}
	return i.Id
}

func (i *IssueTrigger) GetTeamId() *string {
	if i == nil {
		return nil
	}
	return i.TeamId
}

func (i *IssueTrigger) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *IssueTrigger) GetType() IssueType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *IssueTrigger) GetConfigs() *IssueTriggerReference {
	if i == nil {
		return nil
	}
	return i.Configs
}

func (i *IssueTrigger) GetChannels() *IssueTriggerChannels {
	if i == nil {
		return nil
	}
	return i.Channels
}

func (i *IssueTrigger) GetDisabledAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.DisabledAt
}

func (i *IssueTrigger) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *IssueTrigger) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *IssueTrigger) GetDeletedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeletedAt
}

func (i *IssueTrigger) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTrigger) UnmarshalJSON(data []byte) error {
	type embed IssueTrigger
	var unmarshaler = struct {
		embed
		DisabledAt *internal.DateTime `json:"disabled_at,omitempty"`
		UpdatedAt  *internal.DateTime `json:"updated_at"`
		CreatedAt  *internal.DateTime `json:"created_at"`
		DeletedAt  *internal.DateTime `json:"deleted_at,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = IssueTrigger(unmarshaler.embed)
	i.DisabledAt = unmarshaler.DisabledAt.TimePtr()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTrigger) MarshalJSON() ([]byte, error) {
	type embed IssueTrigger
	var marshaler = struct {
		embed
		DisabledAt *internal.DateTime `json:"disabled_at,omitempty"`
		UpdatedAt  *internal.DateTime `json:"updated_at"`
		CreatedAt  *internal.DateTime `json:"created_at"`
		DeletedAt  *internal.DateTime `json:"deleted_at,omitempty"`
	}{
		embed:      embed(*i),
		DisabledAt: internal.NewOptionalDateTime(i.DisabledAt),
		UpdatedAt:  internal.NewDateTime(i.UpdatedAt),
		CreatedAt:  internal.NewDateTime(i.CreatedAt),
		DeletedAt:  internal.NewOptionalDateTime(i.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (i *IssueTrigger) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configurations for a 'Backpressure' issue trigger
type IssueTriggerBackpressureConfigs struct {
	Delay IssueTriggerBackpressureDelay `json:"delay" url:"delay"`
	// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
	Destinations *IssueTriggerBackpressureConfigsDestinations `json:"destinations,omitempty" url:"destinations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerBackpressureConfigs) GetDelay() IssueTriggerBackpressureDelay {
	if i == nil {
		return 0
	}
	return i.Delay
}

func (i *IssueTriggerBackpressureConfigs) GetDestinations() *IssueTriggerBackpressureConfigsDestinations {
	if i == nil {
		return nil
	}
	return i.Destinations
}

func (i *IssueTriggerBackpressureConfigs) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerBackpressureConfigs) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerBackpressureConfigs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerBackpressureConfigs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerBackpressureConfigs) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
type IssueTriggerBackpressureConfigsDestinations struct {
	String     string
	StringList []string

	typ string
}

func NewIssueTriggerBackpressureConfigsDestinationsFromString(value string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typ: "String", String: value}
}

func NewIssueTriggerBackpressureConfigsDestinationsFromStringList(value []string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typ: "StringList", StringList: value}
}

func (i *IssueTriggerBackpressureConfigsDestinations) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *IssueTriggerBackpressureConfigsDestinations) GetStringList() []string {
	if i == nil {
		return nil
	}
	return i.StringList
}

func (i *IssueTriggerBackpressureConfigsDestinations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typ = "StringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerBackpressureConfigsDestinations) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "StringList" || i.StringList != nil {
		return json.Marshal(i.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerBackpressureConfigsDestinationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerBackpressureConfigsDestinations) Accept(visitor IssueTriggerBackpressureConfigsDestinationsVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "StringList" || i.StringList != nil {
		return visitor.VisitStringList(i.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The minimum delay (backpressure) to open the issue for min of 1 minute (60000) and max of 1 day (86400000)
type IssueTriggerBackpressureDelay = int

// Notification channels object for the specific channel type
type IssueTriggerChannels struct {
	Slack     *IssueTriggerSlackChannel       `json:"slack,omitempty" url:"slack,omitempty"`
	Pagerduty *IssueTriggerIntegrationChannel `json:"pagerduty,omitempty" url:"pagerduty,omitempty"`
	Opsgenie  *IssueTriggerIntegrationChannel `json:"opsgenie,omitempty" url:"opsgenie,omitempty"`
	Email     *IssueTriggerEmailChannel       `json:"email,omitempty" url:"email,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerChannels) GetSlack() *IssueTriggerSlackChannel {
	if i == nil {
		return nil
	}
	return i.Slack
}

func (i *IssueTriggerChannels) GetPagerduty() *IssueTriggerIntegrationChannel {
	if i == nil {
		return nil
	}
	return i.Pagerduty
}

func (i *IssueTriggerChannels) GetOpsgenie() *IssueTriggerIntegrationChannel {
	if i == nil {
		return nil
	}
	return i.Opsgenie
}

func (i *IssueTriggerChannels) GetEmail() *IssueTriggerEmailChannel {
	if i == nil {
		return nil
	}
	return i.Email
}

func (i *IssueTriggerChannels) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerChannels) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerChannels
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerChannels(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerChannels) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configurations for a 'delivery' issue trigger
type IssueTriggerDeliveryConfigs struct {
	Strategy IssueTriggerStrategy `json:"strategy" url:"strategy"`
	// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
	Connections *IssueTriggerDeliveryConfigsConnections `json:"connections,omitempty" url:"connections,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerDeliveryConfigs) GetStrategy() IssueTriggerStrategy {
	if i == nil {
		return ""
	}
	return i.Strategy
}

func (i *IssueTriggerDeliveryConfigs) GetConnections() *IssueTriggerDeliveryConfigsConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *IssueTriggerDeliveryConfigs) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerDeliveryConfigs) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerDeliveryConfigs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerDeliveryConfigs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerDeliveryConfigs) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
type IssueTriggerDeliveryConfigsConnections struct {
	String     string
	StringList []string

	typ string
}

func NewIssueTriggerDeliveryConfigsConnectionsFromString(value string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typ: "String", String: value}
}

func NewIssueTriggerDeliveryConfigsConnectionsFromStringList(value []string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typ: "StringList", StringList: value}
}

func (i *IssueTriggerDeliveryConfigsConnections) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *IssueTriggerDeliveryConfigsConnections) GetStringList() []string {
	if i == nil {
		return nil
	}
	return i.StringList
}

func (i *IssueTriggerDeliveryConfigsConnections) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typ = "StringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerDeliveryConfigsConnections) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "StringList" || i.StringList != nil {
		return json.Marshal(i.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerDeliveryConfigsConnectionsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerDeliveryConfigsConnections) Accept(visitor IssueTriggerDeliveryConfigsConnectionsVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "StringList" || i.StringList != nil {
		return visitor.VisitStringList(i.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// Email channel for an issue trigger
type IssueTriggerEmailChannel struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerEmailChannel) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerEmailChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerEmailChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerEmailChannel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerEmailChannel) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Integration channel for an issue trigger
type IssueTriggerIntegrationChannel struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerIntegrationChannel) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerIntegrationChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerIntegrationChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerIntegrationChannel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerIntegrationChannel) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IssueTriggerPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty" url:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty" url:"count,omitempty"`
	Models     []*IssueTrigger `json:"models,omitempty" url:"models,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerPaginatedResult) GetPagination() *SeekPagination {
	if i == nil {
		return nil
	}
	return i.Pagination
}

func (i *IssueTriggerPaginatedResult) GetCount() *int {
	if i == nil {
		return nil
	}
	return i.Count
}

func (i *IssueTriggerPaginatedResult) GetModels() []*IssueTrigger {
	if i == nil {
		return nil
	}
	return i.Models
}

func (i *IssueTriggerPaginatedResult) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerPaginatedResult) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerPaginatedResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerPaginatedResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerPaginatedResult) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration object for the specific issue type selected
type IssueTriggerReference struct {
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs

	typ string
}

func NewIssueTriggerReferenceFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typ: "IssueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typ: "IssueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typ: "IssueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerReference) GetIssueTriggerDeliveryConfigs() *IssueTriggerDeliveryConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerDeliveryConfigs
}

func (i *IssueTriggerReference) GetIssueTriggerTransformationConfigs() *IssueTriggerTransformationConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerTransformationConfigs
}

func (i *IssueTriggerReference) GetIssueTriggerBackpressureConfigs() *IssueTriggerBackpressureConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerBackpressureConfigs
}

func (i *IssueTriggerReference) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typ = "IssueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typ = "IssueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typ = "IssueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerReference) MarshalJSON() ([]byte, error) {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerReferenceVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerReference) Accept(visitor IssueTriggerReferenceVisitor) error {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// Slack channel for an issue trigger
type IssueTriggerSlackChannel struct {
	// Channel name
	ChannelName string `json:"channel_name" url:"channel_name"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerSlackChannel) GetChannelName() string {
	if i == nil {
		return ""
	}
	return i.ChannelName
}

func (i *IssueTriggerSlackChannel) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerSlackChannel) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerSlackChannel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerSlackChannel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerSlackChannel) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The strategy uses to open the issue
type IssueTriggerStrategy string

const (
	IssueTriggerStrategyFirstAttempt IssueTriggerStrategy = "first_attempt"
	IssueTriggerStrategyFinalAttempt IssueTriggerStrategy = "final_attempt"
)

func NewIssueTriggerStrategyFromString(s string) (IssueTriggerStrategy, error) {
	switch s {
	case "first_attempt":
		return IssueTriggerStrategyFirstAttempt, nil
	case "final_attempt":
		return IssueTriggerStrategyFinalAttempt, nil
	}
	var t IssueTriggerStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerStrategy) Ptr() *IssueTriggerStrategy {
	return &i
}

// Configurations for a 'Transformation' issue trigger
type IssueTriggerTransformationConfigs struct {
	LogLevel TransformationExecutionLogLevel `json:"log_level" url:"log_level"`
	// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
	Transformations *IssueTriggerTransformationConfigsTransformations `json:"transformations,omitempty" url:"transformations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IssueTriggerTransformationConfigs) GetLogLevel() TransformationExecutionLogLevel {
	if i == nil {
		return ""
	}
	return i.LogLevel
}

func (i *IssueTriggerTransformationConfigs) GetTransformations() *IssueTriggerTransformationConfigsTransformations {
	if i == nil {
		return nil
	}
	return i.Transformations
}

func (i *IssueTriggerTransformationConfigs) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IssueTriggerTransformationConfigs) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerTransformationConfigs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IssueTriggerTransformationConfigs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IssueTriggerTransformationConfigs) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
type IssueTriggerTransformationConfigsTransformations struct {
	String     string
	StringList []string

	typ string
}

func NewIssueTriggerTransformationConfigsTransformationsFromString(value string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typ: "String", String: value}
}

func NewIssueTriggerTransformationConfigsTransformationsFromStringList(value []string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typ: "StringList", StringList: value}
}

func (i *IssueTriggerTransformationConfigsTransformations) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *IssueTriggerTransformationConfigsTransformations) GetStringList() []string {
	if i == nil {
		return nil
	}
	return i.StringList
}

func (i *IssueTriggerTransformationConfigsTransformations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typ = "StringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerTransformationConfigsTransformations) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "StringList" || i.StringList != nil {
		return json.Marshal(i.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerTransformationConfigsTransformationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerTransformationConfigsTransformations) Accept(visitor IssueTriggerTransformationConfigsTransformationsVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "StringList" || i.StringList != nil {
		return visitor.VisitStringList(i.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// Issue type
type IssueType string

const (
	IssueTypeDelivery       IssueType = "delivery"
	IssueTypeTransformation IssueType = "transformation"
	IssueTypeBackpressure   IssueType = "backpressure"
)

func NewIssueTypeFromString(s string) (IssueType, error) {
	switch s {
	case "delivery":
		return IssueTypeDelivery, nil
	case "transformation":
		return IssueTypeTransformation, nil
	case "backpressure":
		return IssueTypeBackpressure, nil
	}
	var t IssueType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueType) Ptr() *IssueType {
	return &i
}

// Configuration object for the specific issue type selected
type IssueTriggerCreateRequestConfigs struct {
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs

	typ string
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typ: "IssueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typ: "IssueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typ: "IssueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerCreateRequestConfigs) GetIssueTriggerDeliveryConfigs() *IssueTriggerDeliveryConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerDeliveryConfigs
}

func (i *IssueTriggerCreateRequestConfigs) GetIssueTriggerTransformationConfigs() *IssueTriggerTransformationConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerTransformationConfigs
}

func (i *IssueTriggerCreateRequestConfigs) GetIssueTriggerBackpressureConfigs() *IssueTriggerBackpressureConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerBackpressureConfigs
}

func (i *IssueTriggerCreateRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typ = "IssueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typ = "IssueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typ = "IssueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerCreateRequestConfigs) MarshalJSON() ([]byte, error) {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerCreateRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerCreateRequestConfigs) Accept(visitor IssueTriggerCreateRequestConfigsVisitor) error {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerListRequestDir string

const (
	IssueTriggerListRequestDirAsc  IssueTriggerListRequestDir = "asc"
	IssueTriggerListRequestDirDesc IssueTriggerListRequestDir = "desc"
)

func NewIssueTriggerListRequestDirFromString(s string) (IssueTriggerListRequestDir, error) {
	switch s {
	case "asc":
		return IssueTriggerListRequestDirAsc, nil
	case "desc":
		return IssueTriggerListRequestDirDesc, nil
	}
	var t IssueTriggerListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerListRequestDir) Ptr() *IssueTriggerListRequestDir {
	return &i
}

type IssueTriggerListRequestOrderBy string

const (
	IssueTriggerListRequestOrderByCreatedAt IssueTriggerListRequestOrderBy = "created_at"
	IssueTriggerListRequestOrderByType      IssueTriggerListRequestOrderBy = "type"
)

func NewIssueTriggerListRequestOrderByFromString(s string) (IssueTriggerListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueTriggerListRequestOrderByCreatedAt, nil
	case "type":
		return IssueTriggerListRequestOrderByType, nil
	}
	var t IssueTriggerListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerListRequestOrderBy) Ptr() *IssueTriggerListRequestOrderBy {
	return &i
}

// Configuration object for the specific issue type selected
type IssueTriggerUpdateRequestConfigs struct {
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs

	typ string
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typ: "IssueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typ: "IssueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typ: "IssueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerUpdateRequestConfigs) GetIssueTriggerDeliveryConfigs() *IssueTriggerDeliveryConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerDeliveryConfigs
}

func (i *IssueTriggerUpdateRequestConfigs) GetIssueTriggerTransformationConfigs() *IssueTriggerTransformationConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerTransformationConfigs
}

func (i *IssueTriggerUpdateRequestConfigs) GetIssueTriggerBackpressureConfigs() *IssueTriggerBackpressureConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerBackpressureConfigs
}

func (i *IssueTriggerUpdateRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typ = "IssueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typ = "IssueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typ = "IssueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerUpdateRequestConfigs) MarshalJSON() ([]byte, error) {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerUpdateRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerUpdateRequestConfigs) Accept(visitor IssueTriggerUpdateRequestConfigsVisitor) error {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// Configuration object for the specific issue type selected
type IssueTriggerUpsertRequestConfigs struct {
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs

	typ string
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typ: "IssueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typ: "IssueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typ: "IssueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerUpsertRequestConfigs) GetIssueTriggerDeliveryConfigs() *IssueTriggerDeliveryConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerDeliveryConfigs
}

func (i *IssueTriggerUpsertRequestConfigs) GetIssueTriggerTransformationConfigs() *IssueTriggerTransformationConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerTransformationConfigs
}

func (i *IssueTriggerUpsertRequestConfigs) GetIssueTriggerBackpressureConfigs() *IssueTriggerBackpressureConfigs {
	if i == nil {
		return nil
	}
	return i.IssueTriggerBackpressureConfigs
}

func (i *IssueTriggerUpsertRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typ = "IssueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typ = "IssueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typ = "IssueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerUpsertRequestConfigs) MarshalJSON() ([]byte, error) {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerUpsertRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerUpsertRequestConfigs) Accept(visitor IssueTriggerUpsertRequestConfigsVisitor) error {
	if i.typ == "IssueTriggerDeliveryConfigs" || i.IssueTriggerDeliveryConfigs != nil {
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	}
	if i.typ == "IssueTriggerTransformationConfigs" || i.IssueTriggerTransformationConfigs != nil {
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	}
	if i.typ == "IssueTriggerBackpressureConfigs" || i.IssueTriggerBackpressureConfigs != nil {
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueTriggerUpdateRequest struct {
	// Configuration object for the specific issue type selected
	Configs  *core.Optional[IssueTriggerUpdateRequestConfigs] `json:"configs,omitempty" url:"-"`
	Channels *core.Optional[IssueTriggerChannels]             `json:"channels,omitempty" url:"-"`
	// Date when the issue trigger was disabled
	DisabledAt *core.Optional[time.Time] `json:"disabled_at,omitempty" url:"-"`
	// Optional unique name to use as reference when using the API
	Name *core.Optional[string] `json:"name,omitempty" url:"-"`
}

func (i *IssueTriggerUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IssueTriggerUpdateRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*i = IssueTriggerUpdateRequest(body)
	return nil
}

func (i *IssueTriggerUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed IssueTriggerUpdateRequest
	var marshaler = struct {
		embed
		DisabledAt *internal.DateTime `json:"disabled_at,omitempty"`
	}{
		embed:      embed(*i),
		DisabledAt: NewDateTimeFromOptional(i.DisabledAt),
	}
	return json.Marshal(marshaler)
}

type IssueTriggerUpsertRequest struct {
	Type IssueType `json:"type" url:"-"`
	// Configuration object for the specific issue type selected
	Configs  *core.Optional[IssueTriggerUpsertRequestConfigs] `json:"configs,omitempty" url:"-"`
	Channels *core.Optional[IssueTriggerChannels]             `json:"channels,omitempty" url:"-"`
	// Required unique name to use as reference when using the API
	Name string `json:"name" url:"-"`
}
