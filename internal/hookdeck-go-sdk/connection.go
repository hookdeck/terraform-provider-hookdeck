// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/hookdeck/hookdeck-go-sdk/core"
	internal "github.com/hookdeck/hookdeck-go-sdk/internal"
	time "time"
)

type ConnectionCountRequest struct {
	DestinationId []*string  `json:"-" url:"destination_id,omitempty"`
	SourceId      []*string  `json:"-" url:"source_id,omitempty"`
	Disabled      *bool      `json:"-" url:"disabled,omitempty"`
	DisabledAt    *time.Time `json:"-" url:"disabled_at,omitempty"`
	PausedAt      *time.Time `json:"-" url:"paused_at,omitempty"`
}

type ConnectionCreateRequest struct {
	// A unique name of the connection for the source
	Name *core.Optional[string] `json:"name,omitempty" url:"-"`
	// Description for the connection
	Description *core.Optional[string] `json:"description,omitempty" url:"-"`
	// ID of a destination to bind to the connection
	DestinationId *core.Optional[string] `json:"destination_id,omitempty" url:"-"`
	// ID of a source to bind to the connection
	SourceId *core.Optional[string] `json:"source_id,omitempty" url:"-"`
	// Destination input object
	Destination *core.Optional[ConnectionCreateRequestDestination] `json:"destination,omitempty" url:"-"`
	// Source input object
	Source *core.Optional[ConnectionCreateRequestSource] `json:"source,omitempty" url:"-"`
	Rules  *core.Optional[[]*Rule]                       `json:"rules,omitempty" url:"-"`
}

type ConnectionListRequest struct {
	Id            []*string                     `json:"-" url:"id,omitempty"`
	Name          *string                       `json:"-" url:"name,omitempty"`
	DestinationId []*string                     `json:"-" url:"destination_id,omitempty"`
	SourceId      []*string                     `json:"-" url:"source_id,omitempty"`
	Disabled      *bool                         `json:"-" url:"disabled,omitempty"`
	DisabledAt    *time.Time                    `json:"-" url:"disabled_at,omitempty"`
	FullName      *string                       `json:"-" url:"full_name,omitempty"`
	PausedAt      *time.Time                    `json:"-" url:"paused_at,omitempty"`
	OrderBy       *ConnectionListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	Dir           *ConnectionListRequestDir     `json:"-" url:"dir,omitempty"`
	Limit         *int                          `json:"-" url:"limit,omitempty"`
	Next          *string                       `json:"-" url:"next,omitempty"`
	Prev          *string                       `json:"-" url:"prev,omitempty"`
}

type Connection struct {
	// ID of the connection
	Id string `json:"id" url:"id"`
	// Unique name of the connection for this source
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Full name of the connection concatenated from source, connection and desitnation name
	FullName *string `json:"full_name,omitempty" url:"full_name,omitempty"`
	// Description of the connection
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// ID of the project
	TeamId      string       `json:"team_id" url:"team_id"`
	Destination *Destination `json:"destination,omitempty" url:"destination,omitempty"`
	Source      *Source      `json:"source,omitempty" url:"source,omitempty"`
	// Array of rules configured on the connection
	Rules []*Rule `json:"rules,omitempty" url:"rules,omitempty"`
	// Date the connection was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty" url:"disabled_at,omitempty"`
	// Date the connection was paused
	PausedAt *time.Time `json:"paused_at,omitempty" url:"paused_at,omitempty"`
	// Date the connection was last updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Date the connection was created
	CreatedAt time.Time `json:"created_at" url:"created_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Connection) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *Connection) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *Connection) GetFullName() *string {
	if c == nil {
		return nil
	}
	return c.FullName
}

func (c *Connection) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *Connection) GetTeamId() string {
	if c == nil {
		return ""
	}
	return c.TeamId
}

func (c *Connection) GetDestination() *Destination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *Connection) GetSource() *Source {
	if c == nil {
		return nil
	}
	return c.Source
}

func (c *Connection) GetRules() []*Rule {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *Connection) GetDisabledAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.DisabledAt
}

func (c *Connection) GetPausedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.PausedAt
}

func (c *Connection) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *Connection) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *Connection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Connection) UnmarshalJSON(data []byte) error {
	type embed Connection
	var unmarshaler = struct {
		embed
		DisabledAt *internal.DateTime `json:"disabled_at,omitempty"`
		PausedAt   *internal.DateTime `json:"paused_at,omitempty"`
		UpdatedAt  *internal.DateTime `json:"updated_at"`
		CreatedAt  *internal.DateTime `json:"created_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Connection(unmarshaler.embed)
	c.DisabledAt = unmarshaler.DisabledAt.TimePtr()
	c.PausedAt = unmarshaler.PausedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Connection) MarshalJSON() ([]byte, error) {
	type embed Connection
	var marshaler = struct {
		embed
		DisabledAt *internal.DateTime `json:"disabled_at,omitempty"`
		PausedAt   *internal.DateTime `json:"paused_at,omitempty"`
		UpdatedAt  *internal.DateTime `json:"updated_at"`
		CreatedAt  *internal.DateTime `json:"created_at"`
	}{
		embed:      embed(*c),
		DisabledAt: internal.NewOptionalDateTime(c.DisabledAt),
		PausedAt:   internal.NewOptionalDateTime(c.PausedAt),
		UpdatedAt:  internal.NewDateTime(c.UpdatedAt),
		CreatedAt:  internal.NewDateTime(c.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Connection) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty" url:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty" url:"count,omitempty"`
	Models     []*Connection   `json:"models,omitempty" url:"models,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPaginatedResult) GetPagination() *SeekPagination {
	if c == nil {
		return nil
	}
	return c.Pagination
}

func (c *ConnectionPaginatedResult) GetCount() *int {
	if c == nil {
		return nil
	}
	return c.Count
}

func (c *ConnectionPaginatedResult) GetModels() []*Connection {
	if c == nil {
		return nil
	}
	return c.Models
}

func (c *ConnectionPaginatedResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPaginatedResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPaginatedResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPaginatedResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPaginatedResult) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DelayRule struct {
	// Delay to introduce in MS
	Delay int `json:"delay" url:"delay"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DelayRule) GetDelay() int {
	if d == nil {
		return 0
	}
	return d.Delay
}

func (d *DelayRule) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DelayRule) UnmarshalJSON(data []byte) error {
	type unmarshaler DelayRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DelayRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DelayRule) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type FilterRule struct {
	Headers *FilterRuleProperty `json:"headers,omitempty" url:"headers,omitempty"`
	Body    *FilterRuleProperty `json:"body,omitempty" url:"body,omitempty"`
	Query   *FilterRuleProperty `json:"query,omitempty" url:"query,omitempty"`
	Path    *FilterRuleProperty `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterRule) GetHeaders() *FilterRuleProperty {
	if f == nil {
		return nil
	}
	return f.Headers
}

func (f *FilterRule) GetBody() *FilterRuleProperty {
	if f == nil {
		return nil
	}
	return f.Body
}

func (f *FilterRule) GetQuery() *FilterRuleProperty {
	if f == nil {
		return nil
	}
	return f.Query
}

func (f *FilterRule) GetPath() *FilterRuleProperty {
	if f == nil {
		return nil
	}
	return f.Path
}

func (f *FilterRule) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterRule) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// JSON using our filter syntax to filter on request headers
type FilterRuleProperty struct {
	StringOptional           *string
	DoubleOptional           *float64
	BooleanOptional          *bool
	StringUnknownMapOptional map[string]interface{}

	typ string
}

func NewFilterRulePropertyFromStringOptional(value *string) *FilterRuleProperty {
	return &FilterRuleProperty{typ: "StringOptional", StringOptional: value}
}

func NewFilterRulePropertyFromDoubleOptional(value *float64) *FilterRuleProperty {
	return &FilterRuleProperty{typ: "DoubleOptional", DoubleOptional: value}
}

func NewFilterRulePropertyFromBooleanOptional(value *bool) *FilterRuleProperty {
	return &FilterRuleProperty{typ: "BooleanOptional", BooleanOptional: value}
}

func NewFilterRulePropertyFromStringUnknownMapOptional(value map[string]interface{}) *FilterRuleProperty {
	return &FilterRuleProperty{typ: "StringUnknownMapOptional", StringUnknownMapOptional: value}
}

func (f *FilterRuleProperty) GetStringOptional() *string {
	if f == nil {
		return nil
	}
	return f.StringOptional
}

func (f *FilterRuleProperty) GetDoubleOptional() *float64 {
	if f == nil {
		return nil
	}
	return f.DoubleOptional
}

func (f *FilterRuleProperty) GetBooleanOptional() *bool {
	if f == nil {
		return nil
	}
	return f.BooleanOptional
}

func (f *FilterRuleProperty) GetStringUnknownMapOptional() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.StringUnknownMapOptional
}

func (f *FilterRuleProperty) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		f.typ = "StringOptional"
		f.StringOptional = valueStringOptional
		return nil
	}
	var valueDoubleOptional *float64
	if err := json.Unmarshal(data, &valueDoubleOptional); err == nil {
		f.typ = "DoubleOptional"
		f.DoubleOptional = valueDoubleOptional
		return nil
	}
	var valueBooleanOptional *bool
	if err := json.Unmarshal(data, &valueBooleanOptional); err == nil {
		f.typ = "BooleanOptional"
		f.BooleanOptional = valueBooleanOptional
		return nil
	}
	var valueStringUnknownMapOptional map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapOptional); err == nil {
		f.typ = "StringUnknownMapOptional"
		f.StringUnknownMapOptional = valueStringUnknownMapOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilterRuleProperty) MarshalJSON() ([]byte, error) {
	if f.typ == "StringOptional" || f.StringOptional != nil {
		return json.Marshal(f.StringOptional)
	}
	if f.typ == "DoubleOptional" || f.DoubleOptional != nil {
		return json.Marshal(f.DoubleOptional)
	}
	if f.typ == "BooleanOptional" || f.BooleanOptional != nil {
		return json.Marshal(f.BooleanOptional)
	}
	if f.typ == "StringUnknownMapOptional" || f.StringUnknownMapOptional != nil {
		return json.Marshal(f.StringUnknownMapOptional)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilterRulePropertyVisitor interface {
	VisitStringOptional(*string) error
	VisitDoubleOptional(*float64) error
	VisitBooleanOptional(*bool) error
	VisitStringUnknownMapOptional(map[string]interface{}) error
}

func (f *FilterRuleProperty) Accept(visitor FilterRulePropertyVisitor) error {
	if f.typ == "StringOptional" || f.StringOptional != nil {
		return visitor.VisitStringOptional(f.StringOptional)
	}
	if f.typ == "DoubleOptional" || f.DoubleOptional != nil {
		return visitor.VisitDoubleOptional(f.DoubleOptional)
	}
	if f.typ == "BooleanOptional" || f.BooleanOptional != nil {
		return visitor.VisitBooleanOptional(f.BooleanOptional)
	}
	if f.typ == "StringUnknownMapOptional" || f.StringUnknownMapOptional != nil {
		return visitor.VisitStringUnknownMapOptional(f.StringUnknownMapOptional)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type RetryRule struct {
	Strategy RetryStrategy `json:"strategy" url:"strategy"`
	// Time in MS between each retry
	Interval *int `json:"interval,omitempty" url:"interval,omitempty"`
	// Maximum number of retries to attempt
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// HTTP codes to retry on. Accepts: range expressions (e.g., "400-499", ">400"), specific codes (e.g., 404), and exclusions (e.g., "!401"). Example: ["500-599", ">400", 404, "!401"]
	ResponseStatusCodes []string `json:"response_status_codes,omitempty" url:"response_status_codes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetryRule) GetStrategy() RetryStrategy {
	if r == nil {
		return ""
	}
	return r.Strategy
}

func (r *RetryRule) GetInterval() *int {
	if r == nil {
		return nil
	}
	return r.Interval
}

func (r *RetryRule) GetCount() *int {
	if r == nil {
		return nil
	}
	return r.Count
}

func (r *RetryRule) GetResponseStatusCodes() []string {
	if r == nil {
		return nil
	}
	return r.ResponseStatusCodes
}

func (r *RetryRule) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetryRule) UnmarshalJSON(data []byte) error {
	type unmarshaler RetryRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetryRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetryRule) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Algorithm to use when calculating delay between retries
type RetryStrategy string

const (
	RetryStrategyLinear      RetryStrategy = "linear"
	RetryStrategyExponential RetryStrategy = "exponential"
)

func NewRetryStrategyFromString(s string) (RetryStrategy, error) {
	switch s {
	case "linear":
		return RetryStrategyLinear, nil
	case "exponential":
		return RetryStrategyExponential, nil
	}
	var t RetryStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RetryStrategy) Ptr() *RetryStrategy {
	return &r
}

type Rule struct {
	Type      string
	Retry     *RetryRule
	Filter    *FilterRule
	Transform *TransformRule
	Delay     *DelayRule
}

func NewRuleFromRetry(value *RetryRule) *Rule {
	return &Rule{Type: "retry", Retry: value}
}

func NewRuleFromFilter(value *FilterRule) *Rule {
	return &Rule{Type: "filter", Filter: value}
}

func NewRuleFromTransform(value *TransformRule) *Rule {
	return &Rule{Type: "transform", Transform: value}
}

func NewRuleFromDelay(value *DelayRule) *Rule {
	return &Rule{Type: "delay", Delay: value}
}

func (r *Rule) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *Rule) GetRetry() *RetryRule {
	if r == nil {
		return nil
	}
	return r.Retry
}

func (r *Rule) GetFilter() *FilterRule {
	if r == nil {
		return nil
	}
	return r.Filter
}

func (r *Rule) GetTransform() *TransformRule {
	if r == nil {
		return nil
	}
	return r.Transform
}

func (r *Rule) GetDelay() *DelayRule {
	if r == nil {
		return nil
	}
	return r.Delay
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "retry":
		value := new(RetryRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Retry = value
	case "filter":
		value := new(FilterRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Filter = value
	case "transform":
		value := new(TransformRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Transform = value
	case "delay":
		value := new(DelayRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Delay = value
	}
	return nil
}

func (r Rule) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "retry":
		return internal.MarshalJSONWithExtraProperty(r.Retry, "type", "retry")
	case "filter":
		return internal.MarshalJSONWithExtraProperty(r.Filter, "type", "filter")
	case "transform":
		return internal.MarshalJSONWithExtraProperty(r.Transform, "type", "transform")
	case "delay":
		return internal.MarshalJSONWithExtraProperty(r.Delay, "type", "delay")
	}
}

type RuleVisitor interface {
	VisitRetry(*RetryRule) error
	VisitFilter(*FilterRule) error
	VisitTransform(*TransformRule) error
	VisitDelay(*DelayRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "retry":
		return visitor.VisitRetry(r.Retry)
	case "filter":
		return visitor.VisitFilter(r.Filter)
	case "transform":
		return visitor.VisitTransform(r.Transform)
	case "delay":
		return visitor.VisitDelay(r.Delay)
	}
}

type TransformRule struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId *string `json:"transformation_id,omitempty" url:"transformation_id,omitempty"`
	// You can optionally define a new transformation while creating a transform rule
	Transformation *TransformRuleTransformation `json:"transformation,omitempty" url:"transformation,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransformRule) GetTransformationId() *string {
	if t == nil {
		return nil
	}
	return t.TransformationId
}

func (t *TransformRule) GetTransformation() *TransformRuleTransformation {
	if t == nil {
		return nil
	}
	return t.Transformation
}

func (t *TransformRule) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformRule) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformRule) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// You can optionally define a new transformation while creating a transform rule
type TransformRuleTransformation struct {
	// The unique name of the transformation
	Name string `json:"name" url:"name"`
	// A string representation of your JavaScript (ES6) code to run
	Code string `json:"code" url:"code"`
	// A key-value object of environment variables to encrypt and expose to your transformation code
	Env map[string]*string `json:"env,omitempty" url:"env,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransformRuleTransformation) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *TransformRuleTransformation) GetCode() string {
	if t == nil {
		return ""
	}
	return t.Code
}

func (t *TransformRuleTransformation) GetEnv() map[string]*string {
	if t == nil {
		return nil
	}
	return t.Env
}

func (t *TransformRuleTransformation) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformRuleTransformation) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformRuleTransformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformRuleTransformation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformRuleTransformation) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ConnectionCountResponse struct {
	// Count of connections
	Count float64 `json:"count" url:"count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionCountResponse) GetCount() float64 {
	if c == nil {
		return 0
	}
	return c.Count
}

func (c *ConnectionCountResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionCountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionCountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionCountResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionCountResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Destination input object
type ConnectionCreateRequestDestination struct {
	// Name for the destination
	Name string `json:"name" url:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty" url:"cli_path,omitempty"`
	// Limit of events to receive per period. Refered as Delivery Rate limit in the dashboard and documentation.
	RateLimit *int `json:"rate_limit,omitempty" url:"rate_limit,omitempty"`
	// Period to rate limit events by. Refered as Delivery Rate period in the dashboard and documentation.
	RateLimitPeriod        *ConnectionCreateRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty" url:"rate_limit_period,omitempty"`
	HttpMethod             *DestinationHttpMethod                             `json:"http_method,omitempty" url:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig                       `json:"auth_method,omitempty" url:"auth_method,omitempty"`
	PathForwardingDisabled *bool                                              `json:"path_forwarding_disabled,omitempty" url:"path_forwarding_disabled,omitempty"`
	// Type of the destination
	Type   *ConnectionCreateRequestDestinationType `json:"type,omitempty" url:"type,omitempty"`
	Config *DestinationConfig                      `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionCreateRequestDestination) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ConnectionCreateRequestDestination) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ConnectionCreateRequestDestination) GetUrl() *string {
	if c == nil {
		return nil
	}
	return c.Url
}

func (c *ConnectionCreateRequestDestination) GetCliPath() *string {
	if c == nil {
		return nil
	}
	return c.CliPath
}

func (c *ConnectionCreateRequestDestination) GetRateLimit() *int {
	if c == nil {
		return nil
	}
	return c.RateLimit
}

func (c *ConnectionCreateRequestDestination) GetRateLimitPeriod() *ConnectionCreateRequestDestinationRateLimitPeriod {
	if c == nil {
		return nil
	}
	return c.RateLimitPeriod
}

func (c *ConnectionCreateRequestDestination) GetHttpMethod() *DestinationHttpMethod {
	if c == nil {
		return nil
	}
	return c.HttpMethod
}

func (c *ConnectionCreateRequestDestination) GetAuthMethod() *DestinationAuthMethodConfig {
	if c == nil {
		return nil
	}
	return c.AuthMethod
}

func (c *ConnectionCreateRequestDestination) GetPathForwardingDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.PathForwardingDisabled
}

func (c *ConnectionCreateRequestDestination) GetType() *ConnectionCreateRequestDestinationType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ConnectionCreateRequestDestination) GetConfig() *DestinationConfig {
	if c == nil {
		return nil
	}
	return c.Config
}

func (c *ConnectionCreateRequestDestination) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionCreateRequestDestination) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionCreateRequestDestination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionCreateRequestDestination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionCreateRequestDestination) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Period to rate limit events by. Refered as Delivery Rate period in the dashboard and documentation.
type ConnectionCreateRequestDestinationRateLimitPeriod string

const (
	ConnectionCreateRequestDestinationRateLimitPeriodSecond     ConnectionCreateRequestDestinationRateLimitPeriod = "second"
	ConnectionCreateRequestDestinationRateLimitPeriodMinute     ConnectionCreateRequestDestinationRateLimitPeriod = "minute"
	ConnectionCreateRequestDestinationRateLimitPeriodHour       ConnectionCreateRequestDestinationRateLimitPeriod = "hour"
	ConnectionCreateRequestDestinationRateLimitPeriodConcurrent ConnectionCreateRequestDestinationRateLimitPeriod = "concurrent"
)

func NewConnectionCreateRequestDestinationRateLimitPeriodFromString(s string) (ConnectionCreateRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionCreateRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionCreateRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionCreateRequestDestinationRateLimitPeriodHour, nil
	case "concurrent":
		return ConnectionCreateRequestDestinationRateLimitPeriodConcurrent, nil
	}
	var t ConnectionCreateRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionCreateRequestDestinationRateLimitPeriod) Ptr() *ConnectionCreateRequestDestinationRateLimitPeriod {
	return &c
}

// Type of the destination
type ConnectionCreateRequestDestinationType string

const (
	ConnectionCreateRequestDestinationTypeHttp    ConnectionCreateRequestDestinationType = "HTTP"
	ConnectionCreateRequestDestinationTypeCli     ConnectionCreateRequestDestinationType = "CLI"
	ConnectionCreateRequestDestinationTypeMockApi ConnectionCreateRequestDestinationType = "MOCK_API"
)

func NewConnectionCreateRequestDestinationTypeFromString(s string) (ConnectionCreateRequestDestinationType, error) {
	switch s {
	case "HTTP":
		return ConnectionCreateRequestDestinationTypeHttp, nil
	case "CLI":
		return ConnectionCreateRequestDestinationTypeCli, nil
	case "MOCK_API":
		return ConnectionCreateRequestDestinationTypeMockApi, nil
	}
	var t ConnectionCreateRequestDestinationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionCreateRequestDestinationType) Ptr() *ConnectionCreateRequestDestinationType {
	return &c
}

// Source input object
type ConnectionCreateRequestSource struct {
	// A unique name for the source
	Name string `json:"name" url:"name"`
	// Type of the source
	Type *ConnectionCreateRequestSourceType `json:"type,omitempty" url:"type,omitempty"`
	// Description for the source
	Description *string           `json:"description,omitempty" url:"description,omitempty"`
	Config      *SourceTypeConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionCreateRequestSource) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ConnectionCreateRequestSource) GetType() *ConnectionCreateRequestSourceType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ConnectionCreateRequestSource) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ConnectionCreateRequestSource) GetConfig() *SourceTypeConfig {
	if c == nil {
		return nil
	}
	return c.Config
}

func (c *ConnectionCreateRequestSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionCreateRequestSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionCreateRequestSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionCreateRequestSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionCreateRequestSource) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Type of the source
type ConnectionCreateRequestSourceType string

const (
	ConnectionCreateRequestSourceTypeWebhook         ConnectionCreateRequestSourceType = "WEBHOOK"
	ConnectionCreateRequestSourceTypeHttp            ConnectionCreateRequestSourceType = "HTTP"
	ConnectionCreateRequestSourceTypeManaged         ConnectionCreateRequestSourceType = "MANAGED"
	ConnectionCreateRequestSourceTypeSanity          ConnectionCreateRequestSourceType = "SANITY"
	ConnectionCreateRequestSourceTypeBridge          ConnectionCreateRequestSourceType = "BRIDGE"
	ConnectionCreateRequestSourceTypeCloudsignal     ConnectionCreateRequestSourceType = "CLOUDSIGNAL"
	ConnectionCreateRequestSourceTypeCourier         ConnectionCreateRequestSourceType = "COURIER"
	ConnectionCreateRequestSourceTypeFrontapp        ConnectionCreateRequestSourceType = "FRONTAPP"
	ConnectionCreateRequestSourceTypeZoom            ConnectionCreateRequestSourceType = "ZOOM"
	ConnectionCreateRequestSourceTypeTwitter         ConnectionCreateRequestSourceType = "TWITTER"
	ConnectionCreateRequestSourceTypeRecharge        ConnectionCreateRequestSourceType = "RECHARGE"
	ConnectionCreateRequestSourceTypeStripe          ConnectionCreateRequestSourceType = "STRIPE"
	ConnectionCreateRequestSourceTypePropertyFinder  ConnectionCreateRequestSourceType = "PROPERTY-FINDER"
	ConnectionCreateRequestSourceTypeShopify         ConnectionCreateRequestSourceType = "SHOPIFY"
	ConnectionCreateRequestSourceTypeTwilio          ConnectionCreateRequestSourceType = "TWILIO"
	ConnectionCreateRequestSourceTypeGithub          ConnectionCreateRequestSourceType = "GITHUB"
	ConnectionCreateRequestSourceTypePostmark        ConnectionCreateRequestSourceType = "POSTMARK"
	ConnectionCreateRequestSourceTypeTypeform        ConnectionCreateRequestSourceType = "TYPEFORM"
	ConnectionCreateRequestSourceTypeXero            ConnectionCreateRequestSourceType = "XERO"
	ConnectionCreateRequestSourceTypeSvix            ConnectionCreateRequestSourceType = "SVIX"
	ConnectionCreateRequestSourceTypeAdyen           ConnectionCreateRequestSourceType = "ADYEN"
	ConnectionCreateRequestSourceTypeAkeneo          ConnectionCreateRequestSourceType = "AKENEO"
	ConnectionCreateRequestSourceTypeGitlab          ConnectionCreateRequestSourceType = "GITLAB"
	ConnectionCreateRequestSourceTypeWoocommerce     ConnectionCreateRequestSourceType = "WOOCOMMERCE"
	ConnectionCreateRequestSourceTypeOura            ConnectionCreateRequestSourceType = "OURA"
	ConnectionCreateRequestSourceTypeCommercelayer   ConnectionCreateRequestSourceType = "COMMERCELAYER"
	ConnectionCreateRequestSourceTypeHubspot         ConnectionCreateRequestSourceType = "HUBSPOT"
	ConnectionCreateRequestSourceTypeMailgun         ConnectionCreateRequestSourceType = "MAILGUN"
	ConnectionCreateRequestSourceTypePersona         ConnectionCreateRequestSourceType = "PERSONA"
	ConnectionCreateRequestSourceTypePipedrive       ConnectionCreateRequestSourceType = "PIPEDRIVE"
	ConnectionCreateRequestSourceTypeSendgrid        ConnectionCreateRequestSourceType = "SENDGRID"
	ConnectionCreateRequestSourceTypeWorkos          ConnectionCreateRequestSourceType = "WORKOS"
	ConnectionCreateRequestSourceTypeSynctera        ConnectionCreateRequestSourceType = "SYNCTERA"
	ConnectionCreateRequestSourceTypeAwsSns          ConnectionCreateRequestSourceType = "AWS_SNS"
	ConnectionCreateRequestSourceTypeThreeDEye       ConnectionCreateRequestSourceType = "THREE_D_EYE"
	ConnectionCreateRequestSourceTypeTwitch          ConnectionCreateRequestSourceType = "TWITCH"
	ConnectionCreateRequestSourceTypeEnode           ConnectionCreateRequestSourceType = "ENODE"
	ConnectionCreateRequestSourceTypeFavro           ConnectionCreateRequestSourceType = "FAVRO"
	ConnectionCreateRequestSourceTypeLinear          ConnectionCreateRequestSourceType = "LINEAR"
	ConnectionCreateRequestSourceTypeShopline        ConnectionCreateRequestSourceType = "SHOPLINE"
	ConnectionCreateRequestSourceTypeWix             ConnectionCreateRequestSourceType = "WIX"
	ConnectionCreateRequestSourceTypeNmi             ConnectionCreateRequestSourceType = "NMI"
	ConnectionCreateRequestSourceTypeOrb             ConnectionCreateRequestSourceType = "ORB"
	ConnectionCreateRequestSourceTypePylon           ConnectionCreateRequestSourceType = "PYLON"
	ConnectionCreateRequestSourceTypeRazorpay        ConnectionCreateRequestSourceType = "RAZORPAY"
	ConnectionCreateRequestSourceTypeRepay           ConnectionCreateRequestSourceType = "REPAY"
	ConnectionCreateRequestSourceTypeSquare          ConnectionCreateRequestSourceType = "SQUARE"
	ConnectionCreateRequestSourceTypeSolidgate       ConnectionCreateRequestSourceType = "SOLIDGATE"
	ConnectionCreateRequestSourceTypeTrello          ConnectionCreateRequestSourceType = "TRELLO"
	ConnectionCreateRequestSourceTypeEbay            ConnectionCreateRequestSourceType = "EBAY"
	ConnectionCreateRequestSourceTypeTelnyx          ConnectionCreateRequestSourceType = "TELNYX"
	ConnectionCreateRequestSourceTypeDiscord         ConnectionCreateRequestSourceType = "DISCORD"
	ConnectionCreateRequestSourceTypeTokenio         ConnectionCreateRequestSourceType = "TOKENIO"
	ConnectionCreateRequestSourceTypeFiserv          ConnectionCreateRequestSourceType = "FISERV"
	ConnectionCreateRequestSourceTypeBondsmith       ConnectionCreateRequestSourceType = "BONDSMITH"
	ConnectionCreateRequestSourceTypeVercelLogDrains ConnectionCreateRequestSourceType = "VERCEL_LOG_DRAINS"
	ConnectionCreateRequestSourceTypeVercel          ConnectionCreateRequestSourceType = "VERCEL"
	ConnectionCreateRequestSourceTypeTebex           ConnectionCreateRequestSourceType = "TEBEX"
	ConnectionCreateRequestSourceTypeSlack           ConnectionCreateRequestSourceType = "SLACK"
	ConnectionCreateRequestSourceTypeMailchimp       ConnectionCreateRequestSourceType = "MAILCHIMP"
	ConnectionCreateRequestSourceTypePaddle          ConnectionCreateRequestSourceType = "PADDLE"
	ConnectionCreateRequestSourceTypePaypal          ConnectionCreateRequestSourceType = "PAYPAL"
	ConnectionCreateRequestSourceTypeTreezor         ConnectionCreateRequestSourceType = "TREEZOR"
	ConnectionCreateRequestSourceTypePraxis          ConnectionCreateRequestSourceType = "PRAXIS"
	ConnectionCreateRequestSourceTypeCustomerio      ConnectionCreateRequestSourceType = "CUSTOMERIO"
	ConnectionCreateRequestSourceTypeFacebook        ConnectionCreateRequestSourceType = "FACEBOOK"
	ConnectionCreateRequestSourceTypeWhatsapp        ConnectionCreateRequestSourceType = "WHATSAPP"
	ConnectionCreateRequestSourceTypeReplicate       ConnectionCreateRequestSourceType = "REPLICATE"
	ConnectionCreateRequestSourceTypeTiktok          ConnectionCreateRequestSourceType = "TIKTOK"
	ConnectionCreateRequestSourceTypeAirwallex       ConnectionCreateRequestSourceType = "AIRWALLEX"
	ConnectionCreateRequestSourceTypeZendesk         ConnectionCreateRequestSourceType = "ZENDESK"
	ConnectionCreateRequestSourceTypeUpollo          ConnectionCreateRequestSourceType = "UPOLLO"
	ConnectionCreateRequestSourceTypeLinkedin        ConnectionCreateRequestSourceType = "LINKEDIN"
)

func NewConnectionCreateRequestSourceTypeFromString(s string) (ConnectionCreateRequestSourceType, error) {
	switch s {
	case "WEBHOOK":
		return ConnectionCreateRequestSourceTypeWebhook, nil
	case "HTTP":
		return ConnectionCreateRequestSourceTypeHttp, nil
	case "MANAGED":
		return ConnectionCreateRequestSourceTypeManaged, nil
	case "SANITY":
		return ConnectionCreateRequestSourceTypeSanity, nil
	case "BRIDGE":
		return ConnectionCreateRequestSourceTypeBridge, nil
	case "CLOUDSIGNAL":
		return ConnectionCreateRequestSourceTypeCloudsignal, nil
	case "COURIER":
		return ConnectionCreateRequestSourceTypeCourier, nil
	case "FRONTAPP":
		return ConnectionCreateRequestSourceTypeFrontapp, nil
	case "ZOOM":
		return ConnectionCreateRequestSourceTypeZoom, nil
	case "TWITTER":
		return ConnectionCreateRequestSourceTypeTwitter, nil
	case "RECHARGE":
		return ConnectionCreateRequestSourceTypeRecharge, nil
	case "STRIPE":
		return ConnectionCreateRequestSourceTypeStripe, nil
	case "PROPERTY-FINDER":
		return ConnectionCreateRequestSourceTypePropertyFinder, nil
	case "SHOPIFY":
		return ConnectionCreateRequestSourceTypeShopify, nil
	case "TWILIO":
		return ConnectionCreateRequestSourceTypeTwilio, nil
	case "GITHUB":
		return ConnectionCreateRequestSourceTypeGithub, nil
	case "POSTMARK":
		return ConnectionCreateRequestSourceTypePostmark, nil
	case "TYPEFORM":
		return ConnectionCreateRequestSourceTypeTypeform, nil
	case "XERO":
		return ConnectionCreateRequestSourceTypeXero, nil
	case "SVIX":
		return ConnectionCreateRequestSourceTypeSvix, nil
	case "ADYEN":
		return ConnectionCreateRequestSourceTypeAdyen, nil
	case "AKENEO":
		return ConnectionCreateRequestSourceTypeAkeneo, nil
	case "GITLAB":
		return ConnectionCreateRequestSourceTypeGitlab, nil
	case "WOOCOMMERCE":
		return ConnectionCreateRequestSourceTypeWoocommerce, nil
	case "OURA":
		return ConnectionCreateRequestSourceTypeOura, nil
	case "COMMERCELAYER":
		return ConnectionCreateRequestSourceTypeCommercelayer, nil
	case "HUBSPOT":
		return ConnectionCreateRequestSourceTypeHubspot, nil
	case "MAILGUN":
		return ConnectionCreateRequestSourceTypeMailgun, nil
	case "PERSONA":
		return ConnectionCreateRequestSourceTypePersona, nil
	case "PIPEDRIVE":
		return ConnectionCreateRequestSourceTypePipedrive, nil
	case "SENDGRID":
		return ConnectionCreateRequestSourceTypeSendgrid, nil
	case "WORKOS":
		return ConnectionCreateRequestSourceTypeWorkos, nil
	case "SYNCTERA":
		return ConnectionCreateRequestSourceTypeSynctera, nil
	case "AWS_SNS":
		return ConnectionCreateRequestSourceTypeAwsSns, nil
	case "THREE_D_EYE":
		return ConnectionCreateRequestSourceTypeThreeDEye, nil
	case "TWITCH":
		return ConnectionCreateRequestSourceTypeTwitch, nil
	case "ENODE":
		return ConnectionCreateRequestSourceTypeEnode, nil
	case "FAVRO":
		return ConnectionCreateRequestSourceTypeFavro, nil
	case "LINEAR":
		return ConnectionCreateRequestSourceTypeLinear, nil
	case "SHOPLINE":
		return ConnectionCreateRequestSourceTypeShopline, nil
	case "WIX":
		return ConnectionCreateRequestSourceTypeWix, nil
	case "NMI":
		return ConnectionCreateRequestSourceTypeNmi, nil
	case "ORB":
		return ConnectionCreateRequestSourceTypeOrb, nil
	case "PYLON":
		return ConnectionCreateRequestSourceTypePylon, nil
	case "RAZORPAY":
		return ConnectionCreateRequestSourceTypeRazorpay, nil
	case "REPAY":
		return ConnectionCreateRequestSourceTypeRepay, nil
	case "SQUARE":
		return ConnectionCreateRequestSourceTypeSquare, nil
	case "SOLIDGATE":
		return ConnectionCreateRequestSourceTypeSolidgate, nil
	case "TRELLO":
		return ConnectionCreateRequestSourceTypeTrello, nil
	case "EBAY":
		return ConnectionCreateRequestSourceTypeEbay, nil
	case "TELNYX":
		return ConnectionCreateRequestSourceTypeTelnyx, nil
	case "DISCORD":
		return ConnectionCreateRequestSourceTypeDiscord, nil
	case "TOKENIO":
		return ConnectionCreateRequestSourceTypeTokenio, nil
	case "FISERV":
		return ConnectionCreateRequestSourceTypeFiserv, nil
	case "BONDSMITH":
		return ConnectionCreateRequestSourceTypeBondsmith, nil
	case "VERCEL_LOG_DRAINS":
		return ConnectionCreateRequestSourceTypeVercelLogDrains, nil
	case "VERCEL":
		return ConnectionCreateRequestSourceTypeVercel, nil
	case "TEBEX":
		return ConnectionCreateRequestSourceTypeTebex, nil
	case "SLACK":
		return ConnectionCreateRequestSourceTypeSlack, nil
	case "MAILCHIMP":
		return ConnectionCreateRequestSourceTypeMailchimp, nil
	case "PADDLE":
		return ConnectionCreateRequestSourceTypePaddle, nil
	case "PAYPAL":
		return ConnectionCreateRequestSourceTypePaypal, nil
	case "TREEZOR":
		return ConnectionCreateRequestSourceTypeTreezor, nil
	case "PRAXIS":
		return ConnectionCreateRequestSourceTypePraxis, nil
	case "CUSTOMERIO":
		return ConnectionCreateRequestSourceTypeCustomerio, nil
	case "FACEBOOK":
		return ConnectionCreateRequestSourceTypeFacebook, nil
	case "WHATSAPP":
		return ConnectionCreateRequestSourceTypeWhatsapp, nil
	case "REPLICATE":
		return ConnectionCreateRequestSourceTypeReplicate, nil
	case "TIKTOK":
		return ConnectionCreateRequestSourceTypeTiktok, nil
	case "AIRWALLEX":
		return ConnectionCreateRequestSourceTypeAirwallex, nil
	case "ZENDESK":
		return ConnectionCreateRequestSourceTypeZendesk, nil
	case "UPOLLO":
		return ConnectionCreateRequestSourceTypeUpollo, nil
	case "LINKEDIN":
		return ConnectionCreateRequestSourceTypeLinkedin, nil
	}
	var t ConnectionCreateRequestSourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionCreateRequestSourceType) Ptr() *ConnectionCreateRequestSourceType {
	return &c
}

type ConnectionDeleteResponse struct {
	// ID of the connection
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionDeleteResponse) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *ConnectionDeleteResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionDeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionDeleteResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionListRequestDir string

const (
	ConnectionListRequestDirAsc  ConnectionListRequestDir = "asc"
	ConnectionListRequestDirDesc ConnectionListRequestDir = "desc"
)

func NewConnectionListRequestDirFromString(s string) (ConnectionListRequestDir, error) {
	switch s {
	case "asc":
		return ConnectionListRequestDirAsc, nil
	case "desc":
		return ConnectionListRequestDirDesc, nil
	}
	var t ConnectionListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionListRequestDir) Ptr() *ConnectionListRequestDir {
	return &c
}

type ConnectionListRequestOrderBy string

const (
	ConnectionListRequestOrderByCreatedAt             ConnectionListRequestOrderBy = "created_at"
	ConnectionListRequestOrderByUpdatedAt             ConnectionListRequestOrderBy = "updated_at"
	ConnectionListRequestOrderBySourcesUpdatedAt      ConnectionListRequestOrderBy = "sources.updated_at"
	ConnectionListRequestOrderBySourcesCreatedAt      ConnectionListRequestOrderBy = "sources.created_at"
	ConnectionListRequestOrderByDestinationsUpdatedAt ConnectionListRequestOrderBy = "destinations.updated_at"
	ConnectionListRequestOrderByDestinationsCreatedAt ConnectionListRequestOrderBy = "destinations.created_at"
)

func NewConnectionListRequestOrderByFromString(s string) (ConnectionListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return ConnectionListRequestOrderByCreatedAt, nil
	case "updated_at":
		return ConnectionListRequestOrderByUpdatedAt, nil
	case "sources.updated_at":
		return ConnectionListRequestOrderBySourcesUpdatedAt, nil
	case "sources.created_at":
		return ConnectionListRequestOrderBySourcesCreatedAt, nil
	case "destinations.updated_at":
		return ConnectionListRequestOrderByDestinationsUpdatedAt, nil
	case "destinations.created_at":
		return ConnectionListRequestOrderByDestinationsCreatedAt, nil
	}
	var t ConnectionListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionListRequestOrderBy) Ptr() *ConnectionListRequestOrderBy {
	return &c
}

// Destination input object
type ConnectionUpsertRequestDestination struct {
	// Name for the destination
	Name string `json:"name" url:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty" url:"cli_path,omitempty"`
	// Limit of events to receive per period. Refered as Delivery Rate limit in the dashboard and documentation.
	RateLimit *int `json:"rate_limit,omitempty" url:"rate_limit,omitempty"`
	// Period to rate limit events by. Refered as Delivery Rate period in the dashboard and documentation.
	RateLimitPeriod        *ConnectionUpsertRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty" url:"rate_limit_period,omitempty"`
	HttpMethod             *DestinationHttpMethod                             `json:"http_method,omitempty" url:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig                       `json:"auth_method,omitempty" url:"auth_method,omitempty"`
	PathForwardingDisabled *bool                                              `json:"path_forwarding_disabled,omitempty" url:"path_forwarding_disabled,omitempty"`
	// Type of the destination
	Type   *ConnectionUpsertRequestDestinationType `json:"type,omitempty" url:"type,omitempty"`
	Config *DestinationConfig                      `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionUpsertRequestDestination) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ConnectionUpsertRequestDestination) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ConnectionUpsertRequestDestination) GetUrl() *string {
	if c == nil {
		return nil
	}
	return c.Url
}

func (c *ConnectionUpsertRequestDestination) GetCliPath() *string {
	if c == nil {
		return nil
	}
	return c.CliPath
}

func (c *ConnectionUpsertRequestDestination) GetRateLimit() *int {
	if c == nil {
		return nil
	}
	return c.RateLimit
}

func (c *ConnectionUpsertRequestDestination) GetRateLimitPeriod() *ConnectionUpsertRequestDestinationRateLimitPeriod {
	if c == nil {
		return nil
	}
	return c.RateLimitPeriod
}

func (c *ConnectionUpsertRequestDestination) GetHttpMethod() *DestinationHttpMethod {
	if c == nil {
		return nil
	}
	return c.HttpMethod
}

func (c *ConnectionUpsertRequestDestination) GetAuthMethod() *DestinationAuthMethodConfig {
	if c == nil {
		return nil
	}
	return c.AuthMethod
}

func (c *ConnectionUpsertRequestDestination) GetPathForwardingDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.PathForwardingDisabled
}

func (c *ConnectionUpsertRequestDestination) GetType() *ConnectionUpsertRequestDestinationType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ConnectionUpsertRequestDestination) GetConfig() *DestinationConfig {
	if c == nil {
		return nil
	}
	return c.Config
}

func (c *ConnectionUpsertRequestDestination) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionUpsertRequestDestination) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionUpsertRequestDestination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionUpsertRequestDestination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionUpsertRequestDestination) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Period to rate limit events by. Refered as Delivery Rate period in the dashboard and documentation.
type ConnectionUpsertRequestDestinationRateLimitPeriod string

const (
	ConnectionUpsertRequestDestinationRateLimitPeriodSecond     ConnectionUpsertRequestDestinationRateLimitPeriod = "second"
	ConnectionUpsertRequestDestinationRateLimitPeriodMinute     ConnectionUpsertRequestDestinationRateLimitPeriod = "minute"
	ConnectionUpsertRequestDestinationRateLimitPeriodHour       ConnectionUpsertRequestDestinationRateLimitPeriod = "hour"
	ConnectionUpsertRequestDestinationRateLimitPeriodConcurrent ConnectionUpsertRequestDestinationRateLimitPeriod = "concurrent"
)

func NewConnectionUpsertRequestDestinationRateLimitPeriodFromString(s string) (ConnectionUpsertRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionUpsertRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionUpsertRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionUpsertRequestDestinationRateLimitPeriodHour, nil
	case "concurrent":
		return ConnectionUpsertRequestDestinationRateLimitPeriodConcurrent, nil
	}
	var t ConnectionUpsertRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionUpsertRequestDestinationRateLimitPeriod) Ptr() *ConnectionUpsertRequestDestinationRateLimitPeriod {
	return &c
}

// Type of the destination
type ConnectionUpsertRequestDestinationType string

const (
	ConnectionUpsertRequestDestinationTypeHttp    ConnectionUpsertRequestDestinationType = "HTTP"
	ConnectionUpsertRequestDestinationTypeCli     ConnectionUpsertRequestDestinationType = "CLI"
	ConnectionUpsertRequestDestinationTypeMockApi ConnectionUpsertRequestDestinationType = "MOCK_API"
)

func NewConnectionUpsertRequestDestinationTypeFromString(s string) (ConnectionUpsertRequestDestinationType, error) {
	switch s {
	case "HTTP":
		return ConnectionUpsertRequestDestinationTypeHttp, nil
	case "CLI":
		return ConnectionUpsertRequestDestinationTypeCli, nil
	case "MOCK_API":
		return ConnectionUpsertRequestDestinationTypeMockApi, nil
	}
	var t ConnectionUpsertRequestDestinationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionUpsertRequestDestinationType) Ptr() *ConnectionUpsertRequestDestinationType {
	return &c
}

// Source input object
type ConnectionUpsertRequestSource struct {
	// A unique name for the source
	Name string `json:"name" url:"name"`
	// Type of the source
	Type *ConnectionUpsertRequestSourceType `json:"type,omitempty" url:"type,omitempty"`
	// Description for the source
	Description *string           `json:"description,omitempty" url:"description,omitempty"`
	Config      *SourceTypeConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionUpsertRequestSource) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ConnectionUpsertRequestSource) GetType() *ConnectionUpsertRequestSourceType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ConnectionUpsertRequestSource) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ConnectionUpsertRequestSource) GetConfig() *SourceTypeConfig {
	if c == nil {
		return nil
	}
	return c.Config
}

func (c *ConnectionUpsertRequestSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionUpsertRequestSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionUpsertRequestSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionUpsertRequestSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionUpsertRequestSource) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Type of the source
type ConnectionUpsertRequestSourceType string

const (
	ConnectionUpsertRequestSourceTypeWebhook         ConnectionUpsertRequestSourceType = "WEBHOOK"
	ConnectionUpsertRequestSourceTypeHttp            ConnectionUpsertRequestSourceType = "HTTP"
	ConnectionUpsertRequestSourceTypeManaged         ConnectionUpsertRequestSourceType = "MANAGED"
	ConnectionUpsertRequestSourceTypeSanity          ConnectionUpsertRequestSourceType = "SANITY"
	ConnectionUpsertRequestSourceTypeBridge          ConnectionUpsertRequestSourceType = "BRIDGE"
	ConnectionUpsertRequestSourceTypeCloudsignal     ConnectionUpsertRequestSourceType = "CLOUDSIGNAL"
	ConnectionUpsertRequestSourceTypeCourier         ConnectionUpsertRequestSourceType = "COURIER"
	ConnectionUpsertRequestSourceTypeFrontapp        ConnectionUpsertRequestSourceType = "FRONTAPP"
	ConnectionUpsertRequestSourceTypeZoom            ConnectionUpsertRequestSourceType = "ZOOM"
	ConnectionUpsertRequestSourceTypeTwitter         ConnectionUpsertRequestSourceType = "TWITTER"
	ConnectionUpsertRequestSourceTypeRecharge        ConnectionUpsertRequestSourceType = "RECHARGE"
	ConnectionUpsertRequestSourceTypeStripe          ConnectionUpsertRequestSourceType = "STRIPE"
	ConnectionUpsertRequestSourceTypePropertyFinder  ConnectionUpsertRequestSourceType = "PROPERTY-FINDER"
	ConnectionUpsertRequestSourceTypeShopify         ConnectionUpsertRequestSourceType = "SHOPIFY"
	ConnectionUpsertRequestSourceTypeTwilio          ConnectionUpsertRequestSourceType = "TWILIO"
	ConnectionUpsertRequestSourceTypeGithub          ConnectionUpsertRequestSourceType = "GITHUB"
	ConnectionUpsertRequestSourceTypePostmark        ConnectionUpsertRequestSourceType = "POSTMARK"
	ConnectionUpsertRequestSourceTypeTypeform        ConnectionUpsertRequestSourceType = "TYPEFORM"
	ConnectionUpsertRequestSourceTypeXero            ConnectionUpsertRequestSourceType = "XERO"
	ConnectionUpsertRequestSourceTypeSvix            ConnectionUpsertRequestSourceType = "SVIX"
	ConnectionUpsertRequestSourceTypeAdyen           ConnectionUpsertRequestSourceType = "ADYEN"
	ConnectionUpsertRequestSourceTypeAkeneo          ConnectionUpsertRequestSourceType = "AKENEO"
	ConnectionUpsertRequestSourceTypeGitlab          ConnectionUpsertRequestSourceType = "GITLAB"
	ConnectionUpsertRequestSourceTypeWoocommerce     ConnectionUpsertRequestSourceType = "WOOCOMMERCE"
	ConnectionUpsertRequestSourceTypeOura            ConnectionUpsertRequestSourceType = "OURA"
	ConnectionUpsertRequestSourceTypeCommercelayer   ConnectionUpsertRequestSourceType = "COMMERCELAYER"
	ConnectionUpsertRequestSourceTypeHubspot         ConnectionUpsertRequestSourceType = "HUBSPOT"
	ConnectionUpsertRequestSourceTypeMailgun         ConnectionUpsertRequestSourceType = "MAILGUN"
	ConnectionUpsertRequestSourceTypePersona         ConnectionUpsertRequestSourceType = "PERSONA"
	ConnectionUpsertRequestSourceTypePipedrive       ConnectionUpsertRequestSourceType = "PIPEDRIVE"
	ConnectionUpsertRequestSourceTypeSendgrid        ConnectionUpsertRequestSourceType = "SENDGRID"
	ConnectionUpsertRequestSourceTypeWorkos          ConnectionUpsertRequestSourceType = "WORKOS"
	ConnectionUpsertRequestSourceTypeSynctera        ConnectionUpsertRequestSourceType = "SYNCTERA"
	ConnectionUpsertRequestSourceTypeAwsSns          ConnectionUpsertRequestSourceType = "AWS_SNS"
	ConnectionUpsertRequestSourceTypeThreeDEye       ConnectionUpsertRequestSourceType = "THREE_D_EYE"
	ConnectionUpsertRequestSourceTypeTwitch          ConnectionUpsertRequestSourceType = "TWITCH"
	ConnectionUpsertRequestSourceTypeEnode           ConnectionUpsertRequestSourceType = "ENODE"
	ConnectionUpsertRequestSourceTypeFavro           ConnectionUpsertRequestSourceType = "FAVRO"
	ConnectionUpsertRequestSourceTypeLinear          ConnectionUpsertRequestSourceType = "LINEAR"
	ConnectionUpsertRequestSourceTypeShopline        ConnectionUpsertRequestSourceType = "SHOPLINE"
	ConnectionUpsertRequestSourceTypeWix             ConnectionUpsertRequestSourceType = "WIX"
	ConnectionUpsertRequestSourceTypeNmi             ConnectionUpsertRequestSourceType = "NMI"
	ConnectionUpsertRequestSourceTypeOrb             ConnectionUpsertRequestSourceType = "ORB"
	ConnectionUpsertRequestSourceTypePylon           ConnectionUpsertRequestSourceType = "PYLON"
	ConnectionUpsertRequestSourceTypeRazorpay        ConnectionUpsertRequestSourceType = "RAZORPAY"
	ConnectionUpsertRequestSourceTypeRepay           ConnectionUpsertRequestSourceType = "REPAY"
	ConnectionUpsertRequestSourceTypeSquare          ConnectionUpsertRequestSourceType = "SQUARE"
	ConnectionUpsertRequestSourceTypeSolidgate       ConnectionUpsertRequestSourceType = "SOLIDGATE"
	ConnectionUpsertRequestSourceTypeTrello          ConnectionUpsertRequestSourceType = "TRELLO"
	ConnectionUpsertRequestSourceTypeEbay            ConnectionUpsertRequestSourceType = "EBAY"
	ConnectionUpsertRequestSourceTypeTelnyx          ConnectionUpsertRequestSourceType = "TELNYX"
	ConnectionUpsertRequestSourceTypeDiscord         ConnectionUpsertRequestSourceType = "DISCORD"
	ConnectionUpsertRequestSourceTypeTokenio         ConnectionUpsertRequestSourceType = "TOKENIO"
	ConnectionUpsertRequestSourceTypeFiserv          ConnectionUpsertRequestSourceType = "FISERV"
	ConnectionUpsertRequestSourceTypeBondsmith       ConnectionUpsertRequestSourceType = "BONDSMITH"
	ConnectionUpsertRequestSourceTypeVercelLogDrains ConnectionUpsertRequestSourceType = "VERCEL_LOG_DRAINS"
	ConnectionUpsertRequestSourceTypeVercel          ConnectionUpsertRequestSourceType = "VERCEL"
	ConnectionUpsertRequestSourceTypeTebex           ConnectionUpsertRequestSourceType = "TEBEX"
	ConnectionUpsertRequestSourceTypeSlack           ConnectionUpsertRequestSourceType = "SLACK"
	ConnectionUpsertRequestSourceTypeMailchimp       ConnectionUpsertRequestSourceType = "MAILCHIMP"
	ConnectionUpsertRequestSourceTypePaddle          ConnectionUpsertRequestSourceType = "PADDLE"
	ConnectionUpsertRequestSourceTypePaypal          ConnectionUpsertRequestSourceType = "PAYPAL"
	ConnectionUpsertRequestSourceTypeTreezor         ConnectionUpsertRequestSourceType = "TREEZOR"
	ConnectionUpsertRequestSourceTypePraxis          ConnectionUpsertRequestSourceType = "PRAXIS"
	ConnectionUpsertRequestSourceTypeCustomerio      ConnectionUpsertRequestSourceType = "CUSTOMERIO"
	ConnectionUpsertRequestSourceTypeFacebook        ConnectionUpsertRequestSourceType = "FACEBOOK"
	ConnectionUpsertRequestSourceTypeWhatsapp        ConnectionUpsertRequestSourceType = "WHATSAPP"
	ConnectionUpsertRequestSourceTypeReplicate       ConnectionUpsertRequestSourceType = "REPLICATE"
	ConnectionUpsertRequestSourceTypeTiktok          ConnectionUpsertRequestSourceType = "TIKTOK"
	ConnectionUpsertRequestSourceTypeAirwallex       ConnectionUpsertRequestSourceType = "AIRWALLEX"
	ConnectionUpsertRequestSourceTypeZendesk         ConnectionUpsertRequestSourceType = "ZENDESK"
	ConnectionUpsertRequestSourceTypeUpollo          ConnectionUpsertRequestSourceType = "UPOLLO"
	ConnectionUpsertRequestSourceTypeLinkedin        ConnectionUpsertRequestSourceType = "LINKEDIN"
)

func NewConnectionUpsertRequestSourceTypeFromString(s string) (ConnectionUpsertRequestSourceType, error) {
	switch s {
	case "WEBHOOK":
		return ConnectionUpsertRequestSourceTypeWebhook, nil
	case "HTTP":
		return ConnectionUpsertRequestSourceTypeHttp, nil
	case "MANAGED":
		return ConnectionUpsertRequestSourceTypeManaged, nil
	case "SANITY":
		return ConnectionUpsertRequestSourceTypeSanity, nil
	case "BRIDGE":
		return ConnectionUpsertRequestSourceTypeBridge, nil
	case "CLOUDSIGNAL":
		return ConnectionUpsertRequestSourceTypeCloudsignal, nil
	case "COURIER":
		return ConnectionUpsertRequestSourceTypeCourier, nil
	case "FRONTAPP":
		return ConnectionUpsertRequestSourceTypeFrontapp, nil
	case "ZOOM":
		return ConnectionUpsertRequestSourceTypeZoom, nil
	case "TWITTER":
		return ConnectionUpsertRequestSourceTypeTwitter, nil
	case "RECHARGE":
		return ConnectionUpsertRequestSourceTypeRecharge, nil
	case "STRIPE":
		return ConnectionUpsertRequestSourceTypeStripe, nil
	case "PROPERTY-FINDER":
		return ConnectionUpsertRequestSourceTypePropertyFinder, nil
	case "SHOPIFY":
		return ConnectionUpsertRequestSourceTypeShopify, nil
	case "TWILIO":
		return ConnectionUpsertRequestSourceTypeTwilio, nil
	case "GITHUB":
		return ConnectionUpsertRequestSourceTypeGithub, nil
	case "POSTMARK":
		return ConnectionUpsertRequestSourceTypePostmark, nil
	case "TYPEFORM":
		return ConnectionUpsertRequestSourceTypeTypeform, nil
	case "XERO":
		return ConnectionUpsertRequestSourceTypeXero, nil
	case "SVIX":
		return ConnectionUpsertRequestSourceTypeSvix, nil
	case "ADYEN":
		return ConnectionUpsertRequestSourceTypeAdyen, nil
	case "AKENEO":
		return ConnectionUpsertRequestSourceTypeAkeneo, nil
	case "GITLAB":
		return ConnectionUpsertRequestSourceTypeGitlab, nil
	case "WOOCOMMERCE":
		return ConnectionUpsertRequestSourceTypeWoocommerce, nil
	case "OURA":
		return ConnectionUpsertRequestSourceTypeOura, nil
	case "COMMERCELAYER":
		return ConnectionUpsertRequestSourceTypeCommercelayer, nil
	case "HUBSPOT":
		return ConnectionUpsertRequestSourceTypeHubspot, nil
	case "MAILGUN":
		return ConnectionUpsertRequestSourceTypeMailgun, nil
	case "PERSONA":
		return ConnectionUpsertRequestSourceTypePersona, nil
	case "PIPEDRIVE":
		return ConnectionUpsertRequestSourceTypePipedrive, nil
	case "SENDGRID":
		return ConnectionUpsertRequestSourceTypeSendgrid, nil
	case "WORKOS":
		return ConnectionUpsertRequestSourceTypeWorkos, nil
	case "SYNCTERA":
		return ConnectionUpsertRequestSourceTypeSynctera, nil
	case "AWS_SNS":
		return ConnectionUpsertRequestSourceTypeAwsSns, nil
	case "THREE_D_EYE":
		return ConnectionUpsertRequestSourceTypeThreeDEye, nil
	case "TWITCH":
		return ConnectionUpsertRequestSourceTypeTwitch, nil
	case "ENODE":
		return ConnectionUpsertRequestSourceTypeEnode, nil
	case "FAVRO":
		return ConnectionUpsertRequestSourceTypeFavro, nil
	case "LINEAR":
		return ConnectionUpsertRequestSourceTypeLinear, nil
	case "SHOPLINE":
		return ConnectionUpsertRequestSourceTypeShopline, nil
	case "WIX":
		return ConnectionUpsertRequestSourceTypeWix, nil
	case "NMI":
		return ConnectionUpsertRequestSourceTypeNmi, nil
	case "ORB":
		return ConnectionUpsertRequestSourceTypeOrb, nil
	case "PYLON":
		return ConnectionUpsertRequestSourceTypePylon, nil
	case "RAZORPAY":
		return ConnectionUpsertRequestSourceTypeRazorpay, nil
	case "REPAY":
		return ConnectionUpsertRequestSourceTypeRepay, nil
	case "SQUARE":
		return ConnectionUpsertRequestSourceTypeSquare, nil
	case "SOLIDGATE":
		return ConnectionUpsertRequestSourceTypeSolidgate, nil
	case "TRELLO":
		return ConnectionUpsertRequestSourceTypeTrello, nil
	case "EBAY":
		return ConnectionUpsertRequestSourceTypeEbay, nil
	case "TELNYX":
		return ConnectionUpsertRequestSourceTypeTelnyx, nil
	case "DISCORD":
		return ConnectionUpsertRequestSourceTypeDiscord, nil
	case "TOKENIO":
		return ConnectionUpsertRequestSourceTypeTokenio, nil
	case "FISERV":
		return ConnectionUpsertRequestSourceTypeFiserv, nil
	case "BONDSMITH":
		return ConnectionUpsertRequestSourceTypeBondsmith, nil
	case "VERCEL_LOG_DRAINS":
		return ConnectionUpsertRequestSourceTypeVercelLogDrains, nil
	case "VERCEL":
		return ConnectionUpsertRequestSourceTypeVercel, nil
	case "TEBEX":
		return ConnectionUpsertRequestSourceTypeTebex, nil
	case "SLACK":
		return ConnectionUpsertRequestSourceTypeSlack, nil
	case "MAILCHIMP":
		return ConnectionUpsertRequestSourceTypeMailchimp, nil
	case "PADDLE":
		return ConnectionUpsertRequestSourceTypePaddle, nil
	case "PAYPAL":
		return ConnectionUpsertRequestSourceTypePaypal, nil
	case "TREEZOR":
		return ConnectionUpsertRequestSourceTypeTreezor, nil
	case "PRAXIS":
		return ConnectionUpsertRequestSourceTypePraxis, nil
	case "CUSTOMERIO":
		return ConnectionUpsertRequestSourceTypeCustomerio, nil
	case "FACEBOOK":
		return ConnectionUpsertRequestSourceTypeFacebook, nil
	case "WHATSAPP":
		return ConnectionUpsertRequestSourceTypeWhatsapp, nil
	case "REPLICATE":
		return ConnectionUpsertRequestSourceTypeReplicate, nil
	case "TIKTOK":
		return ConnectionUpsertRequestSourceTypeTiktok, nil
	case "AIRWALLEX":
		return ConnectionUpsertRequestSourceTypeAirwallex, nil
	case "ZENDESK":
		return ConnectionUpsertRequestSourceTypeZendesk, nil
	case "UPOLLO":
		return ConnectionUpsertRequestSourceTypeUpollo, nil
	case "LINKEDIN":
		return ConnectionUpsertRequestSourceTypeLinkedin, nil
	}
	var t ConnectionUpsertRequestSourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionUpsertRequestSourceType) Ptr() *ConnectionUpsertRequestSourceType {
	return &c
}

type ConnectionUpdateRequest struct {
	Name *core.Optional[string] `json:"name,omitempty" url:"-"`
	// Description for the connection
	Description *core.Optional[string]  `json:"description,omitempty" url:"-"`
	Rules       *core.Optional[[]*Rule] `json:"rules,omitempty" url:"-"`
}

type ConnectionUpsertRequest struct {
	// A unique name of the connection for the source
	Name *core.Optional[string] `json:"name,omitempty" url:"-"`
	// Description for the connection
	Description *core.Optional[string] `json:"description,omitempty" url:"-"`
	// ID of a destination to bind to the connection
	DestinationId *core.Optional[string] `json:"destination_id,omitempty" url:"-"`
	// ID of a source to bind to the connection
	SourceId *core.Optional[string] `json:"source_id,omitempty" url:"-"`
	// Destination input object
	Destination *core.Optional[ConnectionUpsertRequestDestination] `json:"destination,omitempty" url:"-"`
	// Source input object
	Source *core.Optional[ConnectionUpsertRequestSource] `json:"source,omitempty" url:"-"`
	Rules  *core.Optional[[]*Rule]                       `json:"rules,omitempty" url:"-"`
}
