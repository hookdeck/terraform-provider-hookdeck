// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/hookdeck/hookdeck-go-sdk/core"
	internal "github.com/hookdeck/hookdeck-go-sdk/internal"
	time "time"
)

type BookmarkCreateRequest struct {
	// ID of the event data to bookmark
	EventDataId string `json:"event_data_id" url:"-"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id" url:"-"`
	// Descriptive name of the bookmark
	Label string `json:"label" url:"-"`
	// A unique, human-friendly name for the bookmark
	Name *core.Optional[string] `json:"name,omitempty" url:"-"`
}

type BookmarkListRequest struct {
	Id          []*string                   `json:"-" url:"id,omitempty"`
	Name        []*string                   `json:"-" url:"name,omitempty"`
	WebhookId   []*string                   `json:"-" url:"webhook_id,omitempty"`
	EventDataId []*string                   `json:"-" url:"event_data_id,omitempty"`
	Label       []*string                   `json:"-" url:"label,omitempty"`
	LastUsedAt  *time.Time                  `json:"-" url:"last_used_at,omitempty"`
	OrderBy     *BookmarkListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	Dir         *BookmarkListRequestDir     `json:"-" url:"dir,omitempty"`
	Limit       *int                        `json:"-" url:"limit,omitempty"`
	Next        *string                     `json:"-" url:"next,omitempty"`
	Prev        *string                     `json:"-" url:"prev,omitempty"`
}

type BookmarkTriggerRequest struct {
	// Bookmark target
	Target *core.Optional[BookmarkTriggerRequestTarget] `json:"target,omitempty" url:"-"`
}

type Bookmark struct {
	// ID of the bookmark
	Id string `json:"id" url:"id"`
	// ID of the project
	TeamId string `json:"team_id" url:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id" url:"webhook_id"`
	// ID of the bookmarked event data
	EventDataId string `json:"event_data_id" url:"event_data_id"`
	// Descriptive name of the bookmark
	Label string `json:"label" url:"label"`
	// Alternate alias for the bookmark
	Alias *string         `json:"alias,omitempty" url:"alias,omitempty"`
	Data  *ShortEventData `json:"data,omitempty" url:"data,omitempty"`
	// Date the bookmark was last manually triggered
	LastUsedAt *time.Time `json:"last_used_at,omitempty" url:"last_used_at,omitempty"`
	// Date the bookmark was last updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Date the bookmark was created
	CreatedAt time.Time `json:"created_at" url:"created_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Bookmark) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *Bookmark) GetTeamId() string {
	if b == nil {
		return ""
	}
	return b.TeamId
}

func (b *Bookmark) GetWebhookId() string {
	if b == nil {
		return ""
	}
	return b.WebhookId
}

func (b *Bookmark) GetEventDataId() string {
	if b == nil {
		return ""
	}
	return b.EventDataId
}

func (b *Bookmark) GetLabel() string {
	if b == nil {
		return ""
	}
	return b.Label
}

func (b *Bookmark) GetAlias() *string {
	if b == nil {
		return nil
	}
	return b.Alias
}

func (b *Bookmark) GetData() *ShortEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *Bookmark) GetLastUsedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.LastUsedAt
}

func (b *Bookmark) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *Bookmark) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *Bookmark) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bookmark) UnmarshalJSON(data []byte) error {
	type embed Bookmark
	var unmarshaler = struct {
		embed
		LastUsedAt *internal.DateTime `json:"last_used_at,omitempty"`
		UpdatedAt  *internal.DateTime `json:"updated_at"`
		CreatedAt  *internal.DateTime `json:"created_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Bookmark(unmarshaler.embed)
	b.LastUsedAt = unmarshaler.LastUsedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Bookmark) MarshalJSON() ([]byte, error) {
	type embed Bookmark
	var marshaler = struct {
		embed
		LastUsedAt *internal.DateTime `json:"last_used_at,omitempty"`
		UpdatedAt  *internal.DateTime `json:"updated_at"`
		CreatedAt  *internal.DateTime `json:"created_at"`
	}{
		embed:      embed(*b),
		LastUsedAt: internal.NewOptionalDateTime(b.LastUsedAt),
		UpdatedAt:  internal.NewDateTime(b.UpdatedAt),
		CreatedAt:  internal.NewDateTime(b.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *Bookmark) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookmarkPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty" url:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty" url:"count,omitempty"`
	Models     []*Bookmark     `json:"models,omitempty" url:"models,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookmarkPaginatedResult) GetPagination() *SeekPagination {
	if b == nil {
		return nil
	}
	return b.Pagination
}

func (b *BookmarkPaginatedResult) GetCount() *int {
	if b == nil {
		return nil
	}
	return b.Count
}

func (b *BookmarkPaginatedResult) GetModels() []*Bookmark {
	if b == nil {
		return nil
	}
	return b.Models
}

func (b *BookmarkPaginatedResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookmarkPaginatedResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BookmarkPaginatedResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookmarkPaginatedResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookmarkPaginatedResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type DeletedBookmarkResponse struct {
	// Bookmark ID
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeletedBookmarkResponse) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeletedBookmarkResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletedBookmarkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletedBookmarkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletedBookmarkResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletedBookmarkResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EventArray = []*Event

type BookmarkListRequestDir string

const (
	BookmarkListRequestDirAsc  BookmarkListRequestDir = "asc"
	BookmarkListRequestDirDesc BookmarkListRequestDir = "desc"
)

func NewBookmarkListRequestDirFromString(s string) (BookmarkListRequestDir, error) {
	switch s {
	case "asc":
		return BookmarkListRequestDirAsc, nil
	case "desc":
		return BookmarkListRequestDirDesc, nil
	}
	var t BookmarkListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookmarkListRequestDir) Ptr() *BookmarkListRequestDir {
	return &b
}

type BookmarkListRequestOrderBy string

const (
	BookmarkListRequestOrderByCreatedAt BookmarkListRequestOrderBy = "created_at"
)

func NewBookmarkListRequestOrderByFromString(s string) (BookmarkListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return BookmarkListRequestOrderByCreatedAt, nil
	}
	var t BookmarkListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookmarkListRequestOrderBy) Ptr() *BookmarkListRequestOrderBy {
	return &b
}

// Bookmark target
type BookmarkTriggerRequestTarget string

const (
	BookmarkTriggerRequestTargetHttp BookmarkTriggerRequestTarget = "http"
	BookmarkTriggerRequestTargetCli  BookmarkTriggerRequestTarget = "cli"
)

func NewBookmarkTriggerRequestTargetFromString(s string) (BookmarkTriggerRequestTarget, error) {
	switch s {
	case "http":
		return BookmarkTriggerRequestTargetHttp, nil
	case "cli":
		return BookmarkTriggerRequestTargetCli, nil
	}
	var t BookmarkTriggerRequestTarget
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookmarkTriggerRequestTarget) Ptr() *BookmarkTriggerRequestTarget {
	return &b
}

type BookmarkUpdateRequest struct {
	// ID of the event data to bookmark
	EventDataId *core.Optional[string] `json:"event_data_id,omitempty" url:"-"`
	// ID of the associated connection
	WebhookId *core.Optional[string] `json:"webhook_id,omitempty" url:"-"`
	// Descriptive name of the bookmark
	Label *core.Optional[string] `json:"label,omitempty" url:"-"`
	// A unique, human-friendly name for the bookmark
	Name *core.Optional[string] `json:"name,omitempty" url:"-"`
}
